<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>virtual-context proxy</title>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAHGElEQVRYCZ1WS4gdRRQ93f36vZk3mU9mkkwy+Y4mQZL4iUQhuNAIQUEMaHQTEXeiuHTjRoyQlSCCCILuRBDduTVBwQ9G/CyUREWNiXGSSWYmMZM3n/dtz7m36/XLiC6sme5Xde+te869dauqo+rAcIYMbHpF6rD19jWmXKrMDCW4sZlOs1wfRRRkEqoVc1yfG1MT8a8kfa9CQql6ZbKIcofuLgcy24ARgAQefPbIaJZHYT29hFHqjjQrF/bKnJD5NG2hCyAh0hCZ3IZ+sA5Ewrj4jf9d5UaF3t1KKlKBmI89Np+hdzGrkHlvpYYZWCly9l0ArSdbGGuovma5Ju+wPiLEHPT4YzfLOpSpBb8+Cu9ScB8EvvaypyZO3F9MSBnyZX8xgTiOIv5Sp+I02PDbCqBtdNjN2i2zcQw5YlNBs1vSRI8nphMfmYEQZUSwWH3NIyHvU5aWUOqvIiqV0F5eQsdAOKXT5gbocNwGOgwAbUQJE019Jn/EUKaySH0S0MthXalxpMiVzhzXwme0MR2tWrsegxs2orJ6BG2aJauqqG7ZgmbWxvzPP+PKya/QbjYR8RGJmDy0DBkSZMqMgYUMEaK/OrRixzLJMXkpYkYeW7pjVAYGMLplO5qtOhbnLqOxUHN9QvskwcBNN2PDo4dQmdyMM6+9gYVfz6BTbxKURAicgVlp1PNgLUy+mA0RcDTPg3ChlAVwMikz1SMbNmGewK3lRTPX+htz2bEfJXyYubGD92L9oYM49fxLaC0tI2uIANNPEp0Gl4ruDUM47CVpWjkqaE7nO99qJKDTTE+cpBgZX49rs5focAljW7djw+47UZud9jVlEZYHB7H7yONI+/sw/dlJzJz4FDsOP4jl2atokwQ6QiABEnHwgoIttEPLqGjBcGB4BIvX59Gq1y3Kq1NnSTzD/S+8iM379mHynv144I1XrBCnvv6OWIyRkyf27sFdzzzBQu1noXL9FVDXfYGVL0FX40alslW7qnd0YhP+mr5Ap5xu29G33sjEBPY/9wyiNMGXb76N61MX0DETApVTjO3aiYffOob3Dj2NhfMX0GYAzVrNsiZXoXV3gaojKOwyiRKk5QpaVjhaGi0JbUSChVm7dAnHXz5GUk4I5bLq3P6UgqtnzmFmZg7jd+7G7xcvA9wVagHjBgJGKGdlyeF+jbiXY+1x7Wc16qur12B8120sygqSvhTlKjOl86CvzFSnTFCGn45/jvnpGURc90tn/0S6ZrURzt0rTrnqNp6E4ebryiiRiR6a2+HhXdXB4twMGiRQrpRRJ3icxkjKTkKZa/JQ0pbL2h3Um3x0AMlPCL3LwP2XtEMdUBqHdVu6YdUm1QGebtTx2qrX5jH94w8W0ejkJNbsuJk7NsHcmd9x5Y/zVqTmg9vSTsLRUSxdmDEymc5k+bfw7WXj/C4ItJyEBc9Xq9FAKa1wkrNVgVfpdO8jR9DOljF79hdETP8dhw9hcO0YTrzKA2j2CjKekJXxtUjWrcG173/iDuRELSshHSHH4bi7BIWSUotY85jCxRrSvn40lhdIJMFNdx/AqY8+5DpzZ7AgY56Cv336BdbdshN7jzyGz19/yyIbe+gBzH18EnWeBZkOIvoUrFa0yAJJ+Uloc+xlyeE2VLNjmLzTvj6OmJHmMtPP8ASs45q/uTfK1decBIN7b8fWZ5/GL0ePYfHcH+joXmjxZlxaMBJed0LI7AJXz5rYWXKUAbaOsZYww+rxCVSqQ7a2KrCs0/J1tvteRUcAggzeuhsbn3oSU++8i+U/p2z9uV6eVVsEYci/Y/xnBsRU6ZJppZ+X0eZJNAm0cIWXUe06F5BnAG1i3gP9k9uw7sB9GLp1D86//wGaffMt2rwHMpISORVhlp8pnNRtUbU6zPicjaTEYx5TT62yagIR4cOTcWh8I4a2bEM6PIwOT8FodIg34TZez6tw9fRpTB//BI2ZWQPWN0LWJDivavsW0FIQy1zam/2VBIyE1lcGWlfv2dYzGYko4grviBKfZBV3CYusNnXRI+XyaMm0DT3yHJwxZq2G+TM/1usWoYA8CwZpHySyEAndk/zVP/e3UmLHcd4XSWXHPjryIrI9r/pRffCRWFtRdeNNKI5nd4EPXChxpBlyqnTJkZaaIjm0aueto08qOx+EIbWmq3htoJmeCQM3YhwrCmoK+PyTjFJT+C9NOEFG4QAyp5YCReUgygaTy23kWXEbB1bG7PQMDvWdaLvFBbIKLc+AJZniQuFABVsRMlZyzm6wVFwrm+v4tv9gudLK3a1YAhkZVNc6kDI3xaur/38dx5BvrW7eLOl53yP3OAMhZanXJswT5WBTZGZlIIX1jT3WcF7lJg/AhUO5DNCezJDSQMaXxAH/SSVY98K6d8diBoKJA8kwuOyd5PLeaHvn9cZbkA/EA7kb/Qklwt8iow2TTkVdQwAAAABJRU5ErkJggg==">
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="192x192" href="/dashboard/static/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="/dashboard/static/android-chrome-512x512.png">
<link rel="apple-touch-icon" sizes="180x180" href="/dashboard/static/apple-touch-icon.png">
<link rel="manifest" href="/dashboard/static/site.webmanifest">
<style>
  :root {
    --bg: #0d1117; --surface: #161b22; --border: #30363d;
    --text: #c9d1d9; --text-dim: #8b949e; --accent: #58a6ff;
    --green: #3fb950; --yellow: #d29922; --red: #f85149;
    --purple: #bc8cff; --orange: #d18616;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    background: var(--bg); color: var(--text); font-size: 13px;
    line-height: 1.5;
  }
  .container { max-width: 1100px; margin: 0 auto; padding: 16px; }

  /* Header */
  header {
    display: flex; align-items: center; gap: 12px;
    padding-bottom: 12px; border-bottom: 1px solid var(--border);
    margin-bottom: 16px;
  }
  header h1 { font-size: 16px; font-weight: 600; color: var(--accent); }
  header .dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--green); animation: pulse 2s infinite;
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; } 50% { opacity: 0.4; }
  }
  header .status { color: var(--text-dim); font-size: 12px; margin-left: auto; }
  .shutdown-btn {
    background: transparent; border: 1px solid var(--red); color: var(--red);
    border-radius: 4px; padding: 4px 10px; font-size: 11px; font-weight: 600;
    cursor: pointer; font-family: inherit;
  }
  .shutdown-btn:hover { background: var(--red); color: #fff; }

  /* Stat cards */
  .stats-wrapper { margin-bottom: 16px; }
  .stats {
    display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px;
  }
  .stat {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 6px; padding: 12px; text-align: center;
  }
  .stat .label { font-size: 10px; text-transform: uppercase; color: var(--text-dim); letter-spacing: 0.05em; }
  .stat .value { font-size: 22px; font-weight: 700; color: var(--text); margin-top: 2px; }

  /* Panels */
  .panel {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 6px; padding: 14px; margin-bottom: 14px;
  }
  .panel h2 {
    font-size: 12px; text-transform: uppercase; color: var(--text-dim);
    letter-spacing: 0.05em; margin-bottom: 10px;
  }

  /* Memory bar */
  .memory-bar-track {
    height: 14px; background: var(--bg); border-radius: 4px;
    overflow: hidden; margin-bottom: 6px;
  }
  .memory-bar-fill {
    height: 100%; background: var(--green); border-radius: 4px;
    transition: width 0.4s ease, background 0.4s ease;
  }
  .memory-bar-fill.warn { background: var(--yellow); }
  .memory-bar-fill.crit { background: var(--red); }
  .memory-note { font-size: 11px; color: var(--text-dim); }

  /* Pipeline */
  .pipeline-row {
    display: flex; gap: 24px; font-size: 13px; margin-bottom: 4px;
  }
  .pipeline-row span { color: var(--text-dim); }
  .pipeline-row strong { color: var(--text); }

  /* Tags */
  .tag-cloud { display: flex; flex-wrap: wrap; gap: 6px; }
  .tag {
    background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; padding: 2px 8px; font-size: 11px; color: var(--accent);
  }
  .store-info { font-size: 11px; color: var(--text-dim); margin-top: 8px; }

  /* Request log table */
  .log-table { width: 100%; border-collapse: separate; border-spacing: 0; font-size: 12px; table-layout: fixed; }
  .log-table th {
    text-align: left; padding: 6px 8px; color: var(--text-dim);
    border-bottom: 1px solid var(--border); font-weight: 500;
    position: sticky; top: 0; background: var(--surface); z-index: 10;
  }
  .log-table td { padding: 5px 8px; border-bottom: 1px solid var(--bg); }
  .log-table tr.flash { animation: row-flash 1.5s ease-out; }
  @keyframes row-flash {
    0% { background: rgba(88,166,255,0.15); } 100% { background: transparent; }
  }
  .log-scroll { max-height: 320px; overflow-y: auto; }
  .broad-badge {
    background: var(--purple); color: #fff; border-radius: 3px;
    padding: 1px 5px; font-size: 10px; font-weight: 600;
  }
  .temporal-badge {
    background: var(--orange); color: #fff; border-radius: 3px;
    padding: 1px 5px; font-size: 10px; font-weight: 600;
  }
  .tags-cell { max-width: 140px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .msg-cell { max-width: 280px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: var(--text-dim); }
  .timing-pending { opacity: 0.3; }
  .timing-vc, .timing-llm, .timing-total { white-space: nowrap; font-variant-numeric: tabular-nums; }
  .ingested-row { opacity: 0.5; }
  .ingested-row:hover { opacity: 0.8; }
  .ingested-badge {
    background: var(--border); color: var(--text-dim); border-radius: 3px;
    padding: 1px 5px; font-size: 10px; font-weight: 600;
  }

  /* Compaction events */
  .compaction-entry { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--bg); }
  .compaction-entry:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
  .compaction-header { font-weight: 600; color: var(--text); }
  .compaction-detail { font-size: 11px; color: var(--text-dim); margin-top: 2px; }

  /* Tool intercept events */
  .intercept-entry { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--bg); }
  .intercept-entry:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
  .intercept-header { font-weight: 600; color: var(--text); }
  .intercept-detail { font-size: 11px; color: var(--text-dim); margin-top: 2px; }
  .intercept-result { font-size: 11px; color: var(--text-dim); margin-top: 2px; font-family: monospace; white-space: pre-wrap; max-height: 60px; overflow: auto; }

  .empty-state { color: var(--text-dim); font-style: italic; font-size: 12px; }

  /* Session list */
  .session-list { max-height: 280px; overflow-y: auto; }
  .session-card {
    background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; padding: 8px 10px; margin-bottom: 8px;
  }
  .session-card:last-child { margin-bottom: 0; }
  .session-card.current { border-color: var(--green); }
  .session-card .session-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 4px; gap: 8px;
  }
  .session-card .session-id { font-size: 11px; color: var(--accent); font-family: monospace; word-break: break-all; flex: 1; }
  .session-card .session-header-right {
    display: flex; align-items: center; gap: 6px; flex-shrink: 0;
  }
  .session-card .session-badge {
    background: var(--green); color: #fff; border-radius: 3px;
    padding: 1px 6px; font-size: 10px; font-weight: 600;
  }
  .session-card .metrics-grid {
    display: grid; grid-template-columns: auto 1fr auto 1fr auto 1fr auto 1fr;
    gap: 1px 0; font-size: 11px; margin-top: 4px;
  }
  .session-card .metrics-grid .ml { text-align: right; color: var(--text-dim); padding: 1px 6px 1px 4px; white-space: nowrap; }
  .session-card .metrics-grid .mv { text-align: left; font-weight: 600; padding: 1px 8px 1px 0; white-space: nowrap; }
  .session-card .metrics-grid .mv.green { color: var(--green); }
  .session-card .metrics-grid .mv.yellow { color: var(--yellow); }
  .session-card .metrics-grid .mv.red { color: var(--red); }
  .session-card .util-bar {
    grid-column: 1 / -1; height: 6px; background: var(--bg-lighter);
    border-radius: 3px; overflow: hidden; margin: 1px 0;
  }
  .session-card .util-bar .util-fill {
    height: 100%; background: var(--green); border-radius: 3px;
    transition: width 0.3s ease;
  }
  .session-card .util-bar .util-fill.warn { background: var(--yellow); }
  .session-card .util-bar .util-fill.danger { background: var(--red); }
  .session-card .session-tags { margin-top: 3px; display: flex; flex-wrap: wrap; gap: 4px; }
  .session-card .session-tags .tag { font-size: 10px; padding: 1px 5px; }
  .session-time { font-size: 10px; color: var(--text-dim); margin-top: 4px; }
  .session-delete {
    background: transparent; border: 1px solid var(--red); color: var(--red);
    border-radius: 3px; padding: 1px 6px; font-size: 10px; font-weight: 600;
    cursor: pointer; font-family: inherit;
  }
  .session-delete:hover { background: var(--red); color: #fff; }

  /* Session state badges */
  .state-badge {
    border-radius: 3px; padding: 1px 6px; font-size: 10px; font-weight: 600;
    display: inline-block;
  }
  .state-badge.passthrough { background: var(--yellow); color: #000; }
  .state-badge.ingesting { background: var(--yellow); color: #000; }
  .state-badge.active { background: var(--green); color: #fff; }

  /* Ingestion progress bar */
  .ingestion-progress {
    height: 3px; background: var(--border); border-radius: 2px;
    margin-top: 4px; overflow: hidden;
  }
  .ingestion-progress-fill {
    height: 100%; background: var(--yellow); transition: width 0.3s;
  }

  /* Passthrough row in request log */
  .passthrough-row { opacity: 0.45; }
  .passthrough-row:hover { opacity: 0.7; }
  .passthrough-badge {
    background: var(--yellow); color: #000; border-radius: 3px;
    padding: 1px 5px; font-size: 9px; font-weight: 600;
  }

  /* Passthrough toggle button */
  .passthrough-toggle {
    background: transparent; border: 1px solid var(--accent); color: var(--accent);
    border-radius: 3px; padding: 1px 6px; font-size: 10px; font-weight: 600;
    cursor: pointer; font-family: inherit; margin-left: 6px;
  }
  .passthrough-toggle:hover { background: var(--accent); color: #000; }

  /* Replay panel */
  .replay-controls { display: flex; gap: 8px; align-items: center; margin-bottom: 10px; }
  .replay-controls input[type="text"],
  .replay-controls input[type="password"] {
    background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
    color: var(--text); padding: 5px 8px; font-size: 12px;
    font-family: inherit; flex: 1;
  }
  .replay-controls input::placeholder { color: var(--text-dim); }
  .replay-controls label { font-size: 11px; color: var(--text-dim); min-width: 50px; }
  .replay-btn {
    background: var(--accent); color: #fff; border: none; border-radius: 4px;
    padding: 6px 14px; font-size: 12px; font-weight: 600; cursor: pointer;
    font-family: inherit;
  }
  .replay-btn:hover { opacity: 0.9; }
  .replay-btn:disabled { opacity: 0.4; cursor: default; }
  .replay-btn.stop { background: var(--red); }
  .replay-progress { margin-top: 8px; }
  .replay-bar-track {
    height: 10px; background: var(--bg); border-radius: 4px;
    overflow: hidden; margin-bottom: 4px;
  }
  .replay-bar-fill {
    height: 100%; background: var(--accent); border-radius: 4px;
    transition: width 0.3s ease; width: 0%;
  }
  .replay-bar-fill.done { background: var(--green); }
  .replay-bar-fill.error { background: var(--red); }
  .replay-status { font-size: 11px; color: var(--text-dim); }

  /* Two-column layout for middle panels */
  .two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-bottom: 14px; }

  /* Cost savings panel */
  .savings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  .savings-metric { }
  .savings-metric .label { font-size: 10px; text-transform: uppercase; color: var(--text-dim); letter-spacing: 0.05em; }
  .savings-metric .value { font-size: 18px; font-weight: 700; margin-top: 1px; }
  .savings-metric .value.green { color: var(--green); }
  .savings-detail { font-size: 11px; color: var(--text-dim); margin-top: 2px; }
  .cost-table { width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 10px; }
  .cost-table th { text-align: left; padding: 4px 8px; color: var(--text-dim); border-bottom: 1px solid var(--border); font-weight: 500; }
  .cost-table td { padding: 4px 8px; border-bottom: 1px solid var(--bg); }
  .cost-table td.saved { color: var(--green); font-weight: 600; }

  /* Compact button */
  .compact-btn {
    background: transparent; border: 1px solid var(--yellow); color: var(--yellow);
    border-radius: 4px; padding: 3px 10px; font-size: 11px; font-weight: 600;
    cursor: pointer; font-family: inherit; white-space: nowrap;
  }
  .compact-btn:hover { background: var(--yellow); color: #000; }
  .compact-btn:disabled { opacity: 0.4; cursor: default; }

  /* Settings button */
  .settings-btn {
    background: transparent; border: 1px solid var(--border); color: var(--text-dim);
    border-radius: 4px; padding: 4px 8px; cursor: pointer; display: flex; align-items: center;
  }
  .settings-btn:hover { color: var(--accent); border-color: var(--accent); }

  /* Settings modal */
  .modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.6); z-index: 100;
    display: flex; align-items: center; justify-content: center;
  }
  .modal {
    background: var(--surface); border: 1px solid var(--border); border-radius: 8px;
    width: 580px; max-height: 85vh; display: flex; flex-direction: column;
  }
  .modal-header {
    display: flex; justify-content: space-between; align-items: flex-start;
    padding: 16px 20px; border-bottom: 1px solid var(--border);
  }
  .modal-header h2 { font-size: 14px; font-weight: 600; color: var(--text); margin: 0; }
  .modal-subtitle { font-size: 11px; color: var(--text-dim); margin-top: 2px; }
  .modal-close {
    background: none; border: none; color: var(--text-dim); font-size: 20px;
    cursor: pointer; padding: 0 4px; line-height: 1;
  }
  .modal-close:hover { color: var(--text); }
  .modal-body { padding: 16px 20px; overflow-y: auto; flex: 1; }
  .modal-footer {
    display: flex; justify-content: space-between; align-items: center;
    padding: 12px 20px; border-top: 1px solid var(--border);
  }
  .settings-status { font-size: 11px; color: var(--text-dim); }
  .settings-status.error { color: var(--red); }
  .settings-status.ok { color: var(--green); }

  .settings-section { margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--bg); }
  .settings-section:last-child { border-bottom: none; margin-bottom: 0; }
  .settings-section h3 {
    font-size: 11px; text-transform: uppercase; color: var(--accent);
    letter-spacing: 0.05em; margin-bottom: 8px; font-weight: 600;
  }
  .settings-row {
    display: flex; align-items: flex-start; margin-bottom: 8px; gap: 12px;
  }
  .settings-row .settings-label {
    flex: 0 0 50%; font-size: 12px; color: var(--text-dim); line-height: 1.3;
    padding-top: 3px; text-align: right;
  }
  .settings-row .settings-value { font-size: 12px; color: var(--text); font-weight: 500; padding-top: 3px; }
  .settings-desc { display: block; font-size: 10px; opacity: 0.65; margin-top: 2px; font-weight: 400; }
  .settings-input {
    background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
    color: var(--text); padding: 3px 8px; font-size: 12px; font-family: inherit; width: 100px;
  }
  .settings-input:focus { border-color: var(--accent); outline: none; }
  .settings-slider {
    -webkit-appearance: none; appearance: none; width: 120px; height: 4px;
    background: var(--bg); border-radius: 2px; outline: none;
  }
  .settings-slider::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none; width: 14px; height: 14px;
    border-radius: 50%; background: var(--accent); cursor: pointer;
  }
  .settings-slider-val { font-size: 12px; color: var(--text); min-width: 40px; font-weight: 500; }
  .settings-toggle {
    width: 32px; height: 18px; border-radius: 9px; border: none;
    background: var(--border); cursor: pointer; position: relative;
    transition: background 0.2s;
  }
  .settings-toggle::after {
    content: ''; position: absolute; top: 2px; left: 2px;
    width: 14px; height: 14px; border-radius: 50%;
    background: var(--text-dim); transition: transform 0.2s, background 0.2s;
  }
  .settings-toggle.on { background: var(--green); }
  .settings-toggle.on::after { transform: translateX(14px); background: #fff; }

  .section-header { display: flex; align-items: center; margin-bottom: 8px; }
  .section-header h2, .section-header h3 { margin-bottom: 0; flex: 1; }
  .help-btn {
    width: 18px; height: 18px; border-radius: 50%; border: 1px solid var(--border);
    background: transparent; color: var(--text-dim); font-size: 11px; font-weight: 600;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
    font-family: inherit; line-height: 1; flex-shrink: 0;
  }
  .help-btn:hover { color: var(--accent); border-color: var(--accent); }
  .help-btn.active { color: var(--accent); border-color: var(--accent); }
  .help-content {
    background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
    padding: 10px 12px; margin-bottom: 10px; font-size: 11px;
    line-height: 1.6; color: var(--text-dim);
  }
  .help-content p { margin: 0 0 8px 0; }
  .help-content p:last-child { margin-bottom: 0; }
  .help-content strong { color: var(--text); font-weight: 600; }
  .help-content dl { margin: 0; }
  .help-content dt {
    color: var(--text); font-weight: 600; margin-top: 6px;
  }
  .help-content dt:first-child { margin-top: 0; }
  .help-content dd { margin: 1px 0 0 12px; }

  /* Session column */
  .session-cell { font-family: monospace; font-size: 11px; color: var(--text-dim); cursor: pointer; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 120px; }
  .session-cell:hover { color: var(--accent); }
  .live-badge { background: var(--green); color: #000; font-size: 10px; padding: 1px 5px; border-radius: 3px; margin-left: 4px; }
  #session-filter { padding: 6px 10px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; font-size: 12px; }
  #session-filter code { color: var(--accent); }

  /* Grid: resizable columns */
  .log-table th { position: relative; user-select: none; }
  .col-resize { position: absolute; right: 0; top: 0; bottom: 0; width: 4px; cursor: col-resize; z-index: 11; }
  .col-resize:hover, .col-resize.active { background: var(--accent); }

  /* Grid: draggable columns */
  .log-table th[draggable] { cursor: grab; }
  .log-table th.dragging { opacity: 0.4; }
  .log-table th.drag-over { box-shadow: inset 2px 0 0 var(--accent); }

  /* Grid: column toggle menu */
  .col-toggle-btn { background: none; border: 1px solid var(--border); color: var(--text-dim); padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 11px; margin-left: 6px; }
  .col-toggle-btn:hover { color: var(--text); border-color: var(--text-dim); }
  .col-menu { position: absolute; right: 0; top: 100%; background: var(--surface); border: 1px solid var(--border); border-radius: 4px; padding: 6px 0; z-index: 100; min-width: 160px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
  .col-menu label { display: block; padding: 4px 12px; font-size: 12px; cursor: pointer; white-space: nowrap; }
  .col-menu label:hover { background: var(--bg); }
  .col-menu input[type="checkbox"] { margin-right: 6px; }

  @media (max-width: 700px) {
    .stats { grid-template-columns: repeat(3, 1fr); }
    .two-col { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<div class="container">

<header>
  <div class="dot"></div>
  <h1>virtual-context proxy<span id="instance-label" style="color:var(--text-dim);font-weight:400;font-size:13px"></span></h1>
  <span class="status" id="conn-status">connecting...</span>
  <span class="status" id="ingestion-status" style="margin-left:8px;color:var(--accent)"></span>
  <button class="shutdown-btn" style="border-color:var(--accent);color:var(--accent)" onclick="exportSession()">Export</button>
  <button class="settings-btn" onclick="openSettings()" title="Settings">
    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/></svg>
  </button>
  <button class="shutdown-btn" onclick="shutdownProxy()">Shutdown</button>
</header>

<div class="stats-wrapper">
  <div class="section-header"><h2 style="font-size:12px;text-transform:uppercase;color:var(--text-dim);letter-spacing:0.05em">Overview</h2><button class="help-btn" data-help="overview" onclick="toggleHelp(this)">?</button></div>
  <div class="help-content" data-help-for="overview" style="display:none">
    <p>High-level counters for the current proxy session. These update in real time as requests flow through the proxy.</p>
    <dl>
      <dt>Uptime</dt><dd>How long the proxy server has been running since it was started.</dd>
      <dt>Requests</dt><dd>Total number of LLM requests intercepted and enriched by the proxy. Each request has virtual-context summaries injected before forwarding to the upstream provider.</dd>
      <dt>Turns</dt><dd>Number of completed conversation turns (user message + assistant response pairs). Turns drive the tagging and compaction pipeline.</dd>
      <dt>Compactions</dt><dd>Number of compaction events that have fired. Each compaction summarizes older turns, frees token budget, and stores segments for later retrieval.</dd>
      <dt>Freed</dt><dd>Total tokens reclaimed by compaction. These tokens were occupied by raw conversation history and have been replaced by compressed summaries stored externally.</dd>
    </dl>
  </div>
  <div class="stats">
    <div class="stat"><div class="label">Uptime</div><div class="value" id="s-uptime">--</div></div>
    <div class="stat"><div class="label">Requests</div><div class="value" id="s-requests">0</div></div>
    <div class="stat"><div class="label">Turns</div><div class="value" id="s-turns">0</div></div>
    <div class="stat"><div class="label">Compactions</div><div class="value" id="s-compactions">0</div></div>
    <div class="stat"><div class="label">Intercepts</div><div class="value" id="s-intercepts">0</div></div>
    <div class="stat"><div class="label">Freed</div><div class="value" id="s-freed">0</div></div>
  </div>
</div>

<div class="panel">
  <div class="section-header"><h2>Replay</h2><button class="help-btn" data-help="replay" onclick="toggleHelp(this)">?</button></div>
  <div class="help-content" data-help-for="replay" style="display:none">
    <p>Run a stress test by replaying a file of user prompts through the engine. Each line in the file becomes one conversation turn, processed through the full pipeline: tagging, retrieval, assembly, LLM call, and on_turn_complete. Use this to validate compaction behavior, retrieval accuracy, and context budget management over many turns.</p>
    <dl>
      <dt>File</dt><dd>Path to a text file with one user prompt per line. The proxy will send each line as a user message, call the configured LLM, and record the full turn.</dd>
      <dt>Start / Stop</dt><dd>Begin or halt the replay. Progress is shown in the bar below. Metrics (request log, compaction events, cost savings) update live as turns complete.</dd>
    </dl>
  </div>
  <div class="replay-controls">
    <label>File</label>
    <input type="text" id="replay-file" placeholder="path/to/prompts.txt" value="prompts100.txt">
    <button class="replay-btn" id="replay-start" onclick="startReplay()">Start</button>
    <button class="replay-btn stop" id="replay-stop" onclick="stopReplay()" disabled>Stop</button>
  </div>
  <div class="replay-progress" id="replay-progress" style="display:none">
    <div class="replay-bar-track"><div class="replay-bar-fill" id="replay-fill"></div></div>
    <div class="replay-status" id="replay-status"></div>
  </div>
</div>

<div class="two-col">
  <div class="panel">
    <div class="section-header"><h2>Memory</h2><button class="help-btn" data-help="memory" onclick="toggleHelp(this)">?</button></div>
    <div class="help-content" data-help-for="memory" style="display:none">
      <p>Visualizes how much of the conversation history has been compacted. The bar fills as the compaction watermark advances through the message history. Green means healthy headroom; yellow and red indicate the engine is compacting aggressively to stay within the context window.</p>
      <dl>
        <dt>Bar</dt><dd>Percentage of total messages that have been compacted. The raw messages are replaced by stored summaries that can be retrieved on demand.</dd>
        <dt>Status line</dt><dd>Shows the compaction watermark (how far compaction has reached), total message count, and the configured context window size.</dd>
      </dl>
    </div>
    <div class="memory-bar-track"><div class="memory-bar-fill" id="mem-fill" style="width:0%"></div></div>
    <div style="display:flex;align-items:center;gap:8px">
      <div class="memory-note" id="mem-note" style="flex:1">--</div>
      <button class="compact-btn" id="compact-btn" onclick="compactNow()">Compact Now</button>
    </div>
  </div>
  <div class="panel">
    <div class="section-header"><h2>Pipeline (avg)</h2><button class="help-btn" data-help="pipeline" onclick="toggleHelp(this)">?</button></div>
    <div class="help-content" data-help-for="pipeline" style="display:none">
      <p>Average latency breakdown for each stage of the request processing pipeline, computed across all requests in this session.</p>
      <dl>
        <dt>wait</dt><dd>Time spent waiting for the previous on_turn_complete to finish (runs in a background thread). High values mean compaction or tagging from the prior turn is slow.</dd>
        <dt>inbound</dt><dd>Time for on_message_inbound: tagging the user message, retrieving matching summaries from the store, and assembling the context block. This is the core virtual-context overhead added to each request.</dd>
        <dt>context</dt><dd>Average number of tokens injected into the LLM request as retrieved context. Higher values mean more stored knowledge is being surfaced; zero means no relevant summaries were found.</dd>
      </dl>
    </div>
    <div class="pipeline-row"><span>wait</span> <strong id="p-wait">--</strong></div>
    <div class="pipeline-row"><span>inbound</span> <strong id="p-inbound">--</strong></div>
    <div class="pipeline-row"><span>context</span> <strong id="p-context">--</strong></div>
  </div>
</div>

<div class="panel">
  <div class="section-header"><h2>Cost Savings</h2><button class="help-btn" data-help="cost" onclick="toggleHelp(this)">?</button></div>
  <div class="help-content" data-help-for="cost" style="display:none">
    <p>Compares total input tokens sent by virtual-context against a naive baseline that sends full history each turn, compacting at 30% ratio when it hits the context window. The baseline gets full credit for its own compaction — savings reflect the combined benefit of VC's filtering, selective retrieval, and enrichment over what a standard system would do.</p>
    <dl>
      <dt>Tokens Freed</dt><dd>Total tokens reclaimed by compaction across all compaction events. These tokens were raw conversation history that has been replaced by shorter summaries stored externally.</dd>
      <dt>Summary Compression</dt><dd>Summary tokens divided by original tokens, as a percentage. Lower is better: 20% means summaries are 5x shorter than the originals. Typical values range from 15% to 30%.</dd>
      <dt>Context Injected</dt><dd>Total tokens of retrieved summaries injected across all requests. This is the knowledge the LLM received from stored context that would otherwise have been lost to compaction.</dd>
      <dt>Avg Context / Request</dt><dd>Average tokens injected per request. Shows how much stored knowledge is being surfaced per turn on average.</dd>
      <dt>Session Efficiency</dt><dd>Percentage of input tokens saved compared to a naive baseline system. The baseline simulates a standard chat that sends full history each turn, compacting at 30% ratio when it hits the context window. Higher is better.</dd>
      <dt>Estimated Saved</dt><dd>Dollar savings estimates at common LLM pricing tiers (per million input tokens). Calculated as the difference between baseline and actual cumulative input tokens. Actual savings depend on your provider and model.</dd>
    </dl>
  </div>
  <div class="savings-grid">
    <div class="savings-metric">
      <div class="label">Tokens Freed</div>
      <div class="value green" id="sv-freed">0</div>
      <div class="savings-detail" id="sv-freed-detail">no compactions yet</div>
    </div>
    <div class="savings-metric">
      <div class="label">Summary Compression</div>
      <div class="value green" id="sv-ratio">--</div>
      <div class="savings-detail" id="sv-ratio-detail">original vs summary</div>
    </div>
    <div class="savings-metric">
      <div class="label">Session Efficiency</div>
      <div class="value green" id="sv-efficiency">--</div>
      <div class="savings-detail" id="sv-efficiency-detail">vs naive baseline</div>
    </div>
    <div class="savings-metric">
      <div class="label">Context Injected</div>
      <div class="value" id="sv-injected">0</div>
      <div class="savings-detail" id="sv-injected-detail">total across all requests</div>
    </div>
    <div class="savings-metric">
      <div class="label">Avg Context / Request</div>
      <div class="value" id="sv-avg-ctx">0</div>
      <div class="savings-detail">enrichment per turn</div>
    </div>
    <div class="savings-metric">
      <div class="label">Last Compaction</div>
      <div class="value" id="sv-last-compact">--</div>
      <div class="savings-detail" id="sv-last-compact-detail">no compactions yet</div>
    </div>
  </div>
  <table class="cost-table" id="cost-table">
    <thead><tr><th>Model</th><th>$/MTok</th><th>Baseline</th><th>VC</th><th>Saved</th><th>%</th></tr></thead>
    <tbody id="cost-table-body">
      <tr id="cost-row-placeholder"><td colspan="6" style="color:var(--text-dim)">awaiting first request</td></tr>
    </tbody>
  </table>
</div>

<div class="panel">
  <div class="section-header"><h2>Sessions</h2><button class="help-btn" data-help="sessions" onclick="toggleHelp(this)">?</button></div>
  <div class="help-content" data-help-for="sessions" style="display:none">
    <p>Each proxy run creates a session. When compaction fires, it stores segments tagged with the session ID. This panel shows all sessions that have stored segments, along with their compression stats and tag coverage. The current session is highlighted in green.</p>
    <dl>
      <dt>Segments</dt><dd>Number of compacted segments stored for this session. Each segment represents a group of conversation turns summarized together.</dd>
      <dt>Full Tokens</dt><dd>Total original token count across all segments before compaction.</dd>
      <dt>Compression</dt><dd>Summary-to-original ratio. Lower means more aggressive compression.</dd>
      <dt>Freed</dt><dd>Tokens saved (full tokens minus summary tokens) for this session.</dd>
      <dt>Delete</dt><dd>Remove all stored segments for a past session. Cannot delete the current session.</dd>
    </dl>
  </div>
  <div class="session-list" id="session-list">
    <span class="empty-state">loading sessions...</span>
  </div>
</div>

<div class="panel">
  <div class="section-header"><h2>Active Tags</h2><button class="help-btn" data-help="tags" onclick="toggleHelp(this)">?</button></div>
  <div class="help-content" data-help-for="tags" style="display:none">
    <p>Tags currently in the conversation's working set, based on the most recent turns (controlled by active_tag_lookback). Active tags represent the topics being discussed right now. During retrieval, these tags are <strong>skipped</strong> because their content is already present in the raw conversation history. The store tag count shows how many distinct tags exist across all stored segments.</p>
  </div>
  <div class="tag-cloud" id="tag-cloud"><span class="empty-state">no tags yet</span></div>
  <div class="store-info" id="store-info"></div>
</div>

<div class="panel">
  <div class="section-header" style="position:relative"><h2>Request Log</h2><button class="help-btn" data-help="reqlog" onclick="toggleHelp(this)">?</button><button class="col-toggle-btn" id="unit-toggle" onclick="toggleUnits()">kt</button><button class="col-toggle-btn" onclick="toggleColMenu(this)">Cols</button><button class="col-toggle-btn" onclick="if(gridManager)gridManager.resetDefaults()">Reset</button></div>
  <div class="help-content" data-help-for="reqlog" style="display:none">
    <p>Chronological log of every LLM request processed by the proxy (newest first, max 200 rows). Each row shows one conversation turn from the moment the user message arrives through context injection.</p>
    <dl>
      <dt>T#</dt><dd>Turn number (0-indexed). Corresponds to the conversation turn in the session.</dd>
      <dt>Session</dt><dd>Short prefix of the session UUID this request belongs to. Click to filter the log to just that session. Multiple sessions appear when the proxy serves concurrent conversations.</dd>
      <dt>Tags</dt><dd>Semantic tags assigned to this turn by the tagger, or a <strong style="color:var(--purple)">BROAD</strong> / <strong style="color:var(--orange)">TEMPORAL</strong> badge if the query was detected as broad or temporal. Tags update after on_turn_complete finishes.</dd>
      <dt>Message</dt><dd>Preview of the user message (first 50 characters).</dd>
      <dt>Payload</dt><dd>How many turns were included in the LLM payload after tag-based filtering (filtered/total).</dd>
      <dt>Tokens</dt><dd>Estimated total input tokens sent to the upstream provider for this request (system prompt + enriched messages).</dd>
      <dt>Base</dt><dd>Estimated baseline input tokens a naive system would have sent for this turn — the full unfiltered request payload (all messages + system prompt) before VC filtering. Compare with Tokens to see per-turn savings from VC's selective history filtering.</dd>
      <dt>Injected</dt><dd>Number of tokens of retrieved virtual-context summaries injected into this request.</dd>
      <dt>Timing</dt><dd>Three-part breakdown: <strong>VC</strong> = virtual-context overhead (wait + inbound), <strong>LLM</strong> = upstream API round-trip, <strong>Total</strong> = end-to-end. LLM and Total appear once the upstream response completes.</dd>
    </dl>
  </div>
  <div id="session-filter" style="display:none; margin-bottom:8px; color:var(--text-dim)">
    Showing session: <code id="session-filter-id"></code>
    <a href="#" onclick="clearSessionFilter();return false" style="margin-left:8px;color:var(--accent)">show all</a>
  </div>
  <div class="log-scroll" id="log-scroll">
    <table class="log-table" id="log-table">
      <thead><tr><th>T#</th><th>Session</th><th>Inbound Tags</th><th>Response Tags</th><th>Message</th><th>Payload</th><th>Tokens</th><th>Base</th><th>Injected</th><th>VC</th><th>LLM</th><th>Total</th><th></th></tr></thead>
      <tbody id="log-body"></tbody>
    </table>
  </div>
</div>

<div class="panel">
  <div class="section-header"><h2>Compaction Events</h2><button class="help-btn" data-help="compactions" onclick="toggleHelp(this)">?</button></div>
  <div class="help-content" data-help-for="compactions" style="display:none">
    <p>History of compaction events (newest first). Each entry represents one compaction operation where the engine summarized older conversation turns to free context window space.</p>
    <dl>
      <dt>Turn</dt><dd>The conversation turn that triggered compaction (when token usage crossed the threshold).</dd>
      <dt>Segments</dt><dd>Number of tag-grouped segments that were summarized in this compaction batch.</dd>
      <dt>Freed</dt><dd>Tokens reclaimed by replacing raw conversation turns with compressed summaries.</dd>
      <dt>Tags</dt><dd>The semantic tags covered by the compacted segments. These tags now have stored summaries available for future retrieval.</dd>
      <dt>Tag summaries built</dt><dd>Number of tag-level summaries (re)built. Tag summaries roll up all segment summaries for a given tag into one cohesive summary for efficient retrieval.</dd>
      <dt>Watermark</dt><dd>The compacted_through message index after this compaction. All messages up to this index have been compacted and are no longer in raw history.</dd>
    </dl>
  </div>
  <div id="compaction-list"><span class="empty-state">no compactions yet</span></div>
</div>

<div class="panel">
  <div class="section-header"><h2>Tool Intercepts</h2><button class="help-btn" data-help="intercepts" onclick="toggleHelp(this)">?</button></div>
  <div class="help-content" data-help-for="intercepts" style="display:none">
    <p>History of VC tool interceptions (newest first). When paging is enabled and the LLM calls <code>vc_expand_topic</code> or <code>vc_collapse_topic</code>, the proxy intercepts the tool call, executes it locally against the engine, and sends a continuation request to the upstream LLM. The client never sees these tool calls.</p>
    <dl>
      <dt>Turn</dt><dd>The conversation turn where the tool was intercepted.</dd>
      <dt>Tool</dt><dd>The VC tool that was called (vc_expand_topic or vc_collapse_topic).</dd>
      <dt>Input</dt><dd>The arguments the LLM passed to the tool (tag, depth).</dd>
      <dt>Duration</dt><dd>Time taken to execute the tool locally (typically &lt;10ms).</dd>
      <dt>Result</dt><dd>Truncated result returned to the LLM in the continuation.</dd>
    </dl>
  </div>
  <div id="intercept-list"><span class="empty-state">no tool intercepts yet</span></div>
</div>

</div>

<div class="modal-overlay" id="settings-overlay" style="display:none" onclick="if(event.target===this)closeSettings()">
  <div class="modal">
    <div class="modal-header">
      <div>
        <h2>Settings</h2>
        <div class="modal-subtitle">Changes apply to current session only</div>
      </div>
      <button class="modal-close" onclick="closeSettings()">&times;</button>
    </div>
    <div class="modal-body" id="settings-body">
      <span class="empty-state">loading...</span>
    </div>
    <div class="modal-footer">
      <span class="settings-status" id="settings-status"></span>
      <button class="replay-btn" onclick="saveSettings()">Save</button>
    </div>
  </div>
</div>

<div class="modal-overlay" id="inspect-overlay" style="display:none" onclick="if(event.target===this)closeInspect()">
  <div class="modal" style="max-width:900px;width:90vw">
    <div class="modal-header">
      <div>
        <h2>Request Inspector</h2>
        <div class="modal-subtitle" id="inspect-subtitle">Turn —</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="replay-btn" onclick="saveInspectedRequest()" title="Download raw JSON">Save JSON</button>
        <button class="modal-close" onclick="closeInspect()">&times;</button>
      </div>
    </div>
    <div class="modal-body" id="inspect-body" style="max-height:70vh;overflow:auto;font-size:12px">
      <span class="empty-state">loading...</span>
    </div>
  </div>
</div>

<script>
(function() {
  const $ = id => document.getElementById(id);

  // State
  let totalRequests = 0, totalCompactions = 0, totalFreed = 0, totalIntercepts = 0;
  let totalTurns = 0, contextWindow = 120000;
  let waitSum = 0, inboundSum = 0, contextSum = 0;
  let compactedThrough = 0, historyLen = 0;
  let uptimeBase = 0, uptimeStart = Date.now();
  let autoScroll = true;
  let totalOriginalTokens = 0, totalSummaryTokens = 0, totalContextInjected = 0;
  let cumActualInput = 0, cumBaselineInput = 0, baselineHistoryTokens = 0;
  let latestSystemTokens = 0;
  const BASELINE_RATIO = 0.30;
  let activeSessionFilter = null;
  let liveSessions = [];
  let gridManager = null;
  let unitMode = 'kt'; // 'kt' or '$'
  let lastCompactionEvt = null;

  // Per-model pricing ($/MTok input)
  // $/MTok input — from https://docs.anthropic.com/en/docs/about-claude/pricing
  const MODEL_PRICING = {
    "claude-3-haiku-20240307": 0.25,
    "claude-haiku-4-5-20251001": 1.00,
    "claude-3-5-haiku-20241022": 0.80,
    "claude-3-5-sonnet-20241022": 3.00,
    "claude-sonnet-4-5-20250929": 3.00,
    "claude-sonnet-4-6-20250929": 3.00,
    "claude-opus-4-20250514": 15.00,
    "claude-opus-4-1-20250414": 15.00,
    "claude-opus-4-5-20260715": 5.00,
    "claude-opus-4-6-20260618": 5.00,
  };
  function getModelRate(model) { return MODEL_PRICING[model] || 3.00; }
  function shortModelName(model) {
    if (!model) return 'unknown';
    const m = model.replace(/^claude-/, '').replace(/-\d{8}$/, '');
    return m.length > 20 ? m.substring(0, 20) : m;
  }
  // Track per-model tokens: { model: { actual: N, baseline: N } }
  let modelTokens = {};

  const logScroll = $('log-scroll');
  logScroll.addEventListener('scroll', () => {
    const el = logScroll;
    autoScroll = el.scrollTop + el.clientHeight >= el.scrollHeight - 30;
  });

  function fmtUptime(s) {
    s = Math.floor(s);
    if (s < 60) return s + 's';
    if (s < 3600) return Math.floor(s/60) + 'm ' + (s%60) + 's';
    const h = Math.floor(s/3600);
    const m = Math.floor((s%3600)/60);
    return h + 'h ' + m + 'm';
  }
  function fmtNum(n) { return n >= 1000 ? (n/1000).toFixed(1) + 'k' : String(n); }
  function fmtDollar(tokens, model) {
    const rate = getModelRate(model);
    const cost = (tokens / 1_000_000) * rate;
    return cost < 0.001 ? '<$0.001' : '$' + cost.toFixed(3);
  }
  function fmtTokenCell(tokens, model) {
    if (unitMode === '$') return fmtDollar(tokens, model);
    return fmtNum(tokens) + 't';
  }
  function toggleUnits() {
    unitMode = unitMode === 'kt' ? '$' : 'kt';
    $('unit-toggle').textContent = unitMode;
    // Walk all rows and re-render token cells
    const rows = $('log-body').querySelectorAll('tr');
    rows.forEach(function(tr) {
      const inp = parseInt(tr.dataset.inputTokens) || 0;
      const raw = parseInt(tr.dataset.rawTokens) || 0;
      const ctx = parseInt(tr.dataset.contextTokens) || 0;
      const model = tr.dataset.model || '';
      const cells = tr.querySelectorAll('.token-cell');
      if (cells.length >= 3) {
        cells[0].textContent = inp ? fmtTokenCell(inp, model) : '\u2014';
        if (!cells[1].classList.contains('timing-pending')) {
          cells[1].textContent = raw ? fmtTokenCell(raw, model) : '\u2014';
        }
        cells[2].textContent = fmtTokenCell(ctx, model);
      }
    });
  }
  function fmtTime(ms) {
    if (ms === undefined || ms === null) return '\u2014';
    if (ms < 1000) return Math.round(ms) + 'ms';
    return (ms / 1000).toFixed(1) + 's';
  }

  function updateStats() {
    const elapsed = uptimeBase + (Date.now() - uptimeStart) / 1000;
    $('s-uptime').textContent = fmtUptime(elapsed);
    $('s-requests').textContent = totalRequests;
    $('s-turns').textContent = totalTurns;
    $('s-compactions').textContent = totalCompactions;
    $('s-intercepts').textContent = totalIntercepts;
    $('s-freed').textContent = fmtNum(totalFreed);
  }

  function updatePipeline() {
    if (totalRequests === 0) return;
    $('p-wait').textContent = Math.round(waitSum / totalRequests) + 'ms';
    $('p-inbound').textContent = Math.round(inboundSum / totalRequests) + 'ms';
    $('p-context').textContent = fmtNum(Math.round(contextSum / totalRequests)) + 't';
  }

  function updateMemory() {
    // Rough estimate: compacted_through / history_len as progress
    const pct = historyLen > 0 ? Math.round((compactedThrough / historyLen) * 100) : 0;
    const fill = $('mem-fill');
    fill.style.width = pct + '%';
    fill.className = 'memory-bar-fill' + (pct > 85 ? ' crit' : pct > 70 ? ' warn' : '');
    $('mem-note').textContent = 'compacted through turn ' + Math.floor(compactedThrough / 2) +
      ' \u00b7 ' + historyLen + ' messages \u00b7 window ' + fmtNum(contextWindow) + 't';
  }

  function updateSavings() {
    $('sv-freed').textContent = fmtNum(totalFreed) + 't';
    if (totalOriginalTokens > 0) {
      const ratio = totalSummaryTokens / totalOriginalTokens;
      $('sv-ratio').textContent = Math.round(ratio * 100) + '%';
      $('sv-ratio-detail').textContent = fmtNum(totalOriginalTokens) + 't -> ' + fmtNum(totalSummaryTokens) + 't';
      $('sv-freed-detail').textContent = totalCompactions + ' compaction' + (totalCompactions !== 1 ? 's' : '');
    } else {
      $('sv-ratio').textContent = '--';
    }
    // Session efficiency
    if (cumBaselineInput > 0 && cumActualInput > 0) {
      const savings = Math.max(0, 1 - (cumActualInput / cumBaselineInput));
      $('sv-efficiency').textContent = Math.round(savings * 100) + '%';
      $('sv-efficiency-detail').textContent = fmtNum(cumActualInput) + 't vc vs ' + fmtNum(cumBaselineInput) + 't baseline';
    } else {
      $('sv-efficiency').textContent = '--';
    }

    $('sv-injected').textContent = fmtNum(totalContextInjected) + 't';
    $('sv-avg-ctx').textContent = totalRequests > 0 ? fmtNum(Math.round(totalContextInjected / totalRequests)) + 't' : '0';

    // Model-based cost table: one row per model actually used
    const tbody = $('cost-table-body');
    const models = Object.keys(modelTokens);
    if (models.length === 0) {
      tbody.innerHTML = '<tr><td colspan="6" style="color:var(--text-dim)">awaiting first request</td></tr>';
    } else {
      tbody.innerHTML = '';
      let totalBaseCost = 0, totalVcCost = 0;
      for (const model of models) {
        const mt = modelTokens[model];
        const rate = getModelRate(model);
        const baseM = mt.baseline / 1_000_000;
        const actualM = mt.actual / 1_000_000;
        const savedM = Math.max(0, baseM - actualM);
        const pct = mt.baseline > 0 ? Math.round((Math.max(0, mt.baseline - mt.actual) / mt.baseline) * 100) : 0;
        totalBaseCost += baseM * rate;
        totalVcCost += actualM * rate;
        const tr = document.createElement('tr');
        tr.innerHTML =
          '<td title="' + model + '">' + shortModelName(model) + '</td>' +
          '<td>$' + rate.toFixed(2) + '</td>' +
          '<td>$' + (baseM * rate).toFixed(4) + '</td>' +
          '<td>$' + (actualM * rate).toFixed(4) + '</td>' +
          '<td class="saved">$' + (savedM * rate).toFixed(4) + '</td>' +
          '<td class="saved">' + pct + '%</td>';
        tbody.appendChild(tr);
      }
      // Total row if multiple models
      if (models.length > 1) {
        const totalSaved = Math.max(0, totalBaseCost - totalVcCost);
        const totalPct = totalBaseCost > 0 ? Math.round((totalSaved / totalBaseCost) * 100) : 0;
        const tr = document.createElement('tr');
        tr.style.borderTop = '2px solid var(--border)';
        tr.style.fontWeight = '600';
        tr.innerHTML =
          '<td>Total</td><td></td>' +
          '<td>$' + totalBaseCost.toFixed(4) + '</td>' +
          '<td>$' + totalVcCost.toFixed(4) + '</td>' +
          '<td class="saved">$' + totalSaved.toFixed(4) + '</td>' +
          '<td class="saved">' + totalPct + '%</td>';
        tbody.appendChild(tr);
      }
    }

    // Update last compaction stat
    if (lastCompactionEvt) {
      $('sv-last-compact').textContent = 'T' + lastCompactionEvt.turn;
      $('sv-last-compact-detail').textContent =
        (lastCompactionEvt.segments || 0) + ' segments, ' +
        fmtNum(lastCompactionEvt.tokens_freed || 0) + 't freed';
    }
  }

  function setTags(tags) {
    const cloud = $('tag-cloud');
    if (!tags || tags.length === 0) {
      cloud.innerHTML = '<span class="empty-state">no tags yet</span>';
      return;
    }
    cloud.innerHTML = tags.map(t => '<span class="tag">' + t + '</span>').join('');
  }

  function buildTagCell(tags, broad, temporal) {
    const badges = [];
    if (broad) badges.push('<span class="broad-badge">BROAD</span>');
    if (temporal) badges.push('<span class="temporal-badge">TEMPORAL</span>');
    if (badges.length) return badges.join(' ');
    return (tags || []).join(', ');
  }

  function rowId(sessionId, turn) {
    return 'req-' + (sessionId || '').substring(0, 8) + '-' + turn;
  }

  function addRequestRow(evt) {
    const body = $('log-body');
    const tr = document.createElement('tr');
    tr.className = evt.passthrough ? 'passthrough-row' : 'flash';
    var sid = evt.session_id || '';
    tr.id = rowId(sid, evt.turn);
    tr.dataset.session = sid;
    if (evt.broad) tr.dataset.broad = '1';
    if (evt.temporal) tr.dataset.temporal = '1';
    // Store raw values for kt/$ toggle
    tr.dataset.inputTokens = evt.input_tokens || 0;
    tr.dataset.rawTokens = evt.raw_input_tokens || 0;
    tr.dataset.contextTokens = evt.context_tokens || 0;
    tr.dataset.model = evt.model || '';
    const tagStr = evt.passthrough ? '<span class="passthrough-badge">PASSTHROUGH</span>' : buildTagCell(evt.tags, evt.broad, evt.temporal);
    const preview = (evt.message_preview || '').substring(0, 50);
    const vcMs = evt.overhead_ms !== undefined ? evt.overhead_ms : Math.round((evt.wait_ms || 0) + (evt.inbound_ms || 0));
    // Payload: filtered/total turns
    let payload = '';
    if (evt.filtered_turns !== undefined) {
      payload = evt.filtered_turns + '/' + evt.total_turns;
    } else if (evt.total_turns !== undefined) {
      payload = String(evt.total_turns);
    }
    const tokens = evt.input_tokens ? fmtTokenCell(evt.input_tokens, evt.model) : '\u2014';
    const rawBaseline = evt.raw_input_tokens ? fmtTokenCell(evt.raw_input_tokens, evt.model) : '';
    const injected = fmtTokenCell(evt.context_tokens || 0, evt.model);
    const modelTip = evt.model ? ' title="' + evt.model + '"' : '';
    tr.innerHTML =
      '<td' + modelTip + '>' + (evt.turn ?? '') + '</td>' +
      '<td class="session-cell" title="' + sid + '" onclick="filterBySession(\'' + sid + '\');return false">' + sid + '</td>' +
      '<td class="tags-cell">' + tagStr + '</td>' +
      '<td class="tags-cell resp-tags"></td>' +
      '<td class="msg-cell" title="' + preview.replace(/"/g,'&quot;') + '">' + preview + '</td>' +
      '<td>' + payload + '</td>' +
      '<td class="token-cell">' + tokens + '</td>' +
      '<td class="baseline-cell token-cell' + (rawBaseline ? '' : ' timing-pending') + '">' + (rawBaseline || '\u2014') + '</td>' +
      '<td class="token-cell">' + injected + '</td>' +
      '<td class="timing-vc">' + fmtTime(vcMs) + '</td>' +
      '<td class="timing-llm timing-pending">\u2014</td>' +
      '<td class="timing-total timing-pending">\u2014</td>' +
      '<td><a href="#" onclick="inspectRequest(' + evt.turn + ');return false" style="color:var(--accent);font-size:11px">inspect</a></td>';
    if (gridManager) gridManager.reorderNewRow(tr);
    body.insertBefore(tr, body.firstChild);
    // Track per-model tokens for cost table
    if (evt.model && evt.input_tokens) {
      if (!modelTokens[evt.model]) modelTokens[evt.model] = { actual: 0, baseline: 0 };
      modelTokens[evt.model].actual += evt.input_tokens;
      if (evt.raw_input_tokens) modelTokens[evt.model].baseline += evt.raw_input_tokens;
    }
    // Keep max 200 rows
    while (body.children.length > 200) body.removeChild(body.lastChild);
    if (activeSessionFilter && sid !== activeSessionFilter) tr.style.display = 'none';
    if (autoScroll) logScroll.scrollTop = 0;
  }

  function addIngestedRow(evt) {
    const body = $('log-body');
    const tr = document.createElement('tr');
    tr.className = 'ingested-row';
    var sid = evt.session_id || '';
    tr.id = rowId(sid, evt.turn);
    tr.dataset.session = sid;
    const preview = (evt.message_preview || '').substring(0, 50);
    // Tags go in response column (generated from user+assistant pair)
    var tagHtml = '';
    if (evt.primary_tag) {
      tagHtml = '<strong>' + evt.primary_tag + '</strong>';
      var others = (evt.tags || []).filter(function(t) { return t !== evt.primary_tag; });
      if (others.length) tagHtml += ', ' + others.join(', ');
    } else {
      tagHtml = (evt.tags || []).join(', ');
    }
    tr.innerHTML =
      '<td>' + (evt.turn ?? '') + '</td>' +
      '<td class="session-cell" title="' + sid + '" onclick="filterBySession(\'' + sid + '\');return false">' + sid + '</td>' +
      '<td class="tags-cell"><span class="ingested-badge">HISTORY</span></td>' +
      '<td class="tags-cell resp-tags">' + tagHtml + '</td>' +
      '<td class="msg-cell" title="' + preview.replace(/"/g,'&quot;') + '">' + preview + '</td>' +
      '<td></td><td></td><td class="baseline-cell"></td><td></td>' +
      '<td></td><td></td><td></td><td></td>';
    if (gridManager) gridManager.reorderNewRow(tr);
    body.insertBefore(tr, body.firstChild);
    if (activeSessionFilter && sid !== activeSessionFilter) tr.style.display = 'none';
  }

  let lastSessionFetchTurn = -1;

  function fillResponseTags(row, tags, primaryTag) {
    const respCell = row.querySelector('.resp-tags');
    if (!respCell) return;
    respCell.innerHTML = (tags || []).join(', ');
    if (primaryTag) {
      respCell.innerHTML = '<strong>' + primaryTag + '</strong>' +
        (tags && tags.length > 1 ? ', ' + tags.filter(t => t !== primaryTag).join(', ') : '');
    }
  }

  function handleTurnComplete(evt) {
    const row = $(rowId(evt.session_id, evt.turn));
    if (row) {
      fillResponseTags(row, evt.tags, evt.primary_tag);
      row.className = 'flash';
    }
    totalTurns = Math.max(totalTurns, evt.turn + 1);
    // Baseline accumulation from turn_pair_tokens (fallback for headless mode).
    // In proxy mode the request event provides raw_input_tokens which is more
    // accurate — check whether the baseline cell was already filled.
    const tpt = evt.turn_pair_tokens || 0;
    baselineHistoryTokens += tpt;
    if (baselineHistoryTokens > contextWindow) {
      const prot = tpt * 4;
      const compactable = Math.max(0, baselineHistoryTokens - prot);
      baselineHistoryTokens = Math.round(compactable * BASELINE_RATIO) + prot;
    }
    // Only accumulate turn-pair baseline + update cell if raw baseline wasn't
    // already provided by the request event (cell still shows timing-pending).
    if (row) {
      const baseCell = row.querySelector('.baseline-cell');
      if (baseCell && baseCell.classList.contains('timing-pending')) {
        const fallbackBaseline = latestSystemTokens + baselineHistoryTokens;
        cumBaselineInput += fallbackBaseline;
        baseCell.textContent = fmtNum(fallbackBaseline) + 't';
        baseCell.classList.remove('timing-pending');
      }
    }
    updateStats();
    updateSavings();
    // Refresh active tags from turn_complete data
    if (evt.active_tags) setTags(evt.active_tags);
    if (evt.store_tag_count !== undefined) {
      $('store-info').textContent = evt.store_tag_count + ' tags in store';
    }
    // Refresh sessions every 5 turns (compaction may have stored new segments)
    if (evt.turn - lastSessionFetchTurn >= 5) {
      lastSessionFetchTurn = evt.turn;
      fetchSessions();
    }
  }

  function handleResponse(evt) {
    const row = $(rowId(evt.session_id, evt.turn));
    if (!row) return;
    const llmCell = row.querySelector('.timing-llm');
    const totalCell = row.querySelector('.timing-total');
    if (llmCell) {
      llmCell.textContent = fmtTime(evt.upstream_ms);
      llmCell.classList.remove('timing-pending');
    }
    if (totalCell) {
      totalCell.textContent = fmtTime(evt.total_ms);
      totalCell.classList.remove('timing-pending');
    }
    if (evt.error) row.style.opacity = '0.6';
  }

  function addCompaction(evt) {
    const list = $('compaction-list');
    if (list.querySelector('.empty-state')) list.innerHTML = '';
    const div = document.createElement('div');
    div.className = 'compaction-entry';
    div.innerHTML =
      '<div class="compaction-header">T' + evt.turn + ' \u00b7 ' +
      evt.segments + ' segments \u00b7 freed ' + fmtNum(evt.tokens_freed || 0) + 't' +
      ' \u00b7 [' + (evt.tags || []).join(', ') + ']</div>' +
      '<div class="compaction-detail">Built ' + (evt.tag_summaries_built || 0) +
      ' tag summaries \u00b7 watermark ' + (evt.compacted_through || 0) + '</div>';
    list.insertBefore(div, list.firstChild);
    compactedThrough = evt.compacted_through || compactedThrough;
    lastCompactionEvt = evt;
    updateMemory();
    updateSavings();
  }

  function addToolIntercept(evt) {
    const list = $('intercept-list');
    if (list.querySelector('.empty-state')) list.innerHTML = '';
    const div = document.createElement('div');
    div.className = 'intercept-entry';
    const input = typeof evt.tool_input === 'object' ? JSON.stringify(evt.tool_input) : (evt.tool_input || '');
    div.innerHTML =
      '<div class="intercept-header">T' + (evt.turn || '?') + ' \u00b7 ' +
      (evt.tool_name || 'unknown') + '(' + input + ')' +
      ' \u00b7 ' + (evt.duration_ms || 0) + 'ms</div>' +
      '<div class="intercept-result">' + (evt.result || '').replace(/</g, '&lt;') + '</div>';
    list.insertBefore(div, list.firstChild);
  }

  function handleSnapshot(data) {
    uptimeBase = data.uptime_s || 0;
    uptimeStart = Date.now();
    totalRequests = data.total_requests || 0;
    totalCompactions = data.total_compactions || 0;
    totalFreed = data.total_tokens_freed || 0;
    totalOriginalTokens = data.total_original_tokens || 0;
    totalSummaryTokens = data.total_summary_tokens || 0;
    totalContextInjected = data.total_context_injected || 0;
    cumActualInput = data.total_actual_input || 0;
    cumBaselineInput = data.total_baseline_input || 0;
    waitSum = (data.avg_wait_ms || 0) * totalRequests;
    inboundSum = (data.avg_inbound_ms || 0) * totalRequests;
    contextSum = (data.avg_context_tokens || 0) * totalRequests;
    compactedThrough = data.compacted_through || 0;
    historyLen = data.history_len || 0;
    contextWindow = data.context_window || 120000;
    totalTurns = data.history_len ? Math.floor(data.history_len / 2) : totalRequests;

    // Set latestSystemTokens from snapshot requests
    if (data.recent_requests && data.recent_requests.length) {
      latestSystemTokens = data.recent_requests[data.recent_requests.length - 1].system_tokens || 0;
    }

    liveSessions = data.live_sessions || [];

    // Instance label (multi-instance mode)
    if (data.instance_label) {
      $('instance-label').textContent = ' [' + data.instance_label + ']';
      document.title = 'vc proxy [' + data.instance_label + ']';
    }

    // Rebuild per-model token tracking from snapshot
    modelTokens = {};
    (data.recent_requests || []).forEach(function(r) {
      if (r.model && r.input_tokens) {
        if (!modelTokens[r.model]) modelTokens[r.model] = { actual: 0, baseline: 0 };
        modelTokens[r.model].actual += r.input_tokens;
        if (r.raw_input_tokens) modelTokens[r.model].baseline += r.raw_input_tokens;
      }
    });

    // Restore last compaction event from snapshot
    var snapCompactions = data.compactions || [];
    if (snapCompactions.length > 0) {
      lastCompactionEvt = snapCompactions[snapCompactions.length - 1];
    }

    updateStats();
    updatePipeline();
    updateMemory();
    updateSavings();
    fetchSessions();
    setTags(data.active_tags || []);
    if (data.store_tag_count !== undefined) {
      $('store-info').textContent = data.store_tag_count + ' tags in store';
    }

    // Fill ingested history turns (iterate oldest-first so prepend produces newest-at-top)
    var ingested = data.ingested_turns || [];
    for (var ii = 0; ii < ingested.length; ii++) addIngestedRow(ingested[ii]);
    // Fill request log (prepended = newest at top)
    (data.recent_requests || []).forEach(r => addRequestRow(r));
    // Fill response timing
    (data.responses || []).forEach(r => handleResponse(r));
    // Bootstrap baseline from ingested history BEFORE processing live turn_completes
    var snapBaselineHist = 0;
    (data.history_ingestions || []).forEach(function(h) {
      if (h.baseline_history_tokens) snapBaselineHist = h.baseline_history_tokens;
      handleHistoryIngestion(h);
    });
    // Process turn_completes: fill response tags + fallback baseline for cells
    // not already populated by raw_input_tokens from the request event.
    (data.turn_completes || []).forEach(function(tc) {
      var row = $(rowId(tc.session_id, tc.turn));
      if (row && tc.tags && tc.tags.length) {
        fillResponseTags(row, tc.tags, tc.primary_tag);
      }
      var tpt = tc.turn_pair_tokens || 0;
      snapBaselineHist += tpt;
      if (snapBaselineHist > contextWindow) {
        var prot = tpt * 4;
        var compactable = Math.max(0, snapBaselineHist - prot);
        snapBaselineHist = Math.round(compactable * BASELINE_RATIO) + prot;
      }
      // Only fill baseline cell if raw_input_tokens didn't already fill it
      if (row) {
        var baseCell = row.querySelector('.baseline-cell');
        if (baseCell && baseCell.classList.contains('timing-pending')) {
          baseCell.textContent = fmtNum(latestSystemTokens + snapBaselineHist) + 't';
          baseCell.classList.remove('timing-pending');
        }
      }
    });
    baselineHistoryTokens = snapBaselineHist;
    // Fill compactions
    (data.compactions || []).forEach(c => addCompaction(c));

    // Fill tool intercepts
    totalIntercepts = data.total_tool_intercepts || 0;
    (data.tool_intercepts || []).forEach(ti => addToolIntercept(ti));
    updateStats();
  }

  // Sessions
  var storedSessions = [];

  function fetchSessions() {
    fetch('/dashboard/sessions')
      .then(r => r.json())
      .then(data => {
        storedSessions = data.sessions || [];
        renderSessionsPanel();
      })
      .catch(() => {});
  }

  function fetchLiveSessions() {
    fetch('/dashboard/sessions/live')
      .then(r => r.json())
      .then(data => {
        liveSessions = data || [];
        renderSessionsPanel();
      })
      .catch(() => {});
  }

  function renderSessionsPanel() {
    var list = $('session-list');
    var storedMap = {};
    (storedSessions || []).forEach(function(s) { storedMap[s.session_id] = s; });
    var liveMap = {};
    (liveSessions || []).forEach(function(s) { liveMap[s.session_id] = s; });

    // Merge: all live sessions + stored-only sessions
    var allIds = [];
    var seen = {};
    (liveSessions || []).forEach(function(s) {
      if (!seen[s.session_id]) { allIds.push(s.session_id); seen[s.session_id] = true; }
    });
    (storedSessions || []).forEach(function(s) {
      if (!seen[s.session_id]) { allIds.push(s.session_id); seen[s.session_id] = true; }
    });

    if (allIds.length === 0) {
      list.innerHTML = '<span class="empty-state">no sessions yet</span>';
      return;
    }

    list.innerHTML = allIds.map(function(sid) {
      var live = liveMap[sid];
      var stored = storedMap[sid];
      var isCurrent = stored ? stored.is_current : !!live;
      var isLiveOnly = live && !stored;

      var html = '<div class="session-card' + (isCurrent ? ' current' : '') +
        '" style="cursor:pointer" onclick="filterBySession(\'' + sid + '\')">' +
        '<div class="session-header">' +
          '<span class="session-id">' + sid + '</span>' +
          '<div class="session-header-right">';

      if (live && live.session_state) {
        var st = live.session_state;
        var stLabel = st.toUpperCase();
        html += '<span class="state-badge ' + st + '">' + stLabel + '</span>';
        var toggleLabel = live.manual_passthrough ? 'Enable VC' : 'Disable VC';
        html += '<button class="passthrough-toggle" onclick="event.stopPropagation();togglePassthrough(\'' + sid + '\',' + !live.manual_passthrough + ')">' + toggleLabel + '</button>';
      } else if (isLiveOnly) {
        html += '<span class="live-badge">LIVE</span>';
      } else if (isCurrent) {
        html += '<span class="session-badge">CURRENT</span>';
      }

      if (stored && !isCurrent) {
        html += '<button class="session-delete" onclick="event.stopPropagation();deleteSession(\'' + sid + '\')">Delete</button>';
      }
      html += '</div></div>';

      // Ingestion progress bar
      if (live && live.session_state === 'ingesting' && live.ingestion_progress) {
        var done = live.ingestion_progress[0] || 0;
        var total = live.ingestion_progress[1] || 1;
        var pct = Math.round((done / total) * 100);
        html += '<div class="ingestion-progress"><div class="ingestion-progress-fill" style="width:' + pct + '%"></div></div>';
        html += '<div class="ingestion-progress-label" style="font-size:10px;color:var(--text-dim);margin-top:2px">Ingesting: ' + done + '/' + total + ' (' + pct + '%)</div>';
      }

      // Metrics grid — 4 label/value columns, labels right-aligned, values left-aligned
      function fmtTokens(t) {
        if (t >= 10000) return Math.round(t / 1000) + 'k';
        if (t >= 1000) return (t / 1000).toFixed(1) + 'k';
        return t + '';
      }
      function fmtKB(kb) {
        if (kb === null || kb === undefined) return '--';
        if (kb >= 1024) return (kb / 1024).toFixed(1) + 'MB';
        return kb.toFixed(1) + 'KB';
      }
      function fmtPayload(kb, tokens) {
        var s = fmtKB(kb);
        if (tokens) s += ' / ' + fmtTokens(tokens) + 't';
        return s;
      }
      function mc(label, val, cls) {
        var valCls = cls ? ' ' + cls : '';
        return '<span class="ml">' + label + '</span><span class="mv' + valCls + '">' + val + '</span>';
      }
      // empty pair to fill unused grid slots
      function me() { return '<span class="ml"></span><span class="mv"></span>'; }

      html += '<div class="metrics-grid">';

      if (live) {
        var initT = live.initial_turns != null ? live.initial_turns : '--';
        var initTags = live.initial_tag_count != null ? live.initial_tag_count : '--';
        // Row 1: live requests, turns, tags, compacted
        html += mc('Live', live.live_requests || 0);
        html += mc('Turns', initT + '\u2192' + live.turn_count);
        html += mc('Tags', initTags + '\u2192' + live.tag_count);
        html += mc('Compacted', 'T' + Math.floor(live.compacted_through / 2));

        // Row 2: window, history, utilization, segments/summaries
        var cw = live.context_window || 0;
        var ht = live.history_tokens || 0;
        var utilPct = live.utilization_pct || 0;
        var utilClass = utilPct > 85 ? 'red' : (utilPct > 60 ? 'yellow' : 'green');
        var barClass = utilPct > 85 ? 'danger' : (utilPct > 60 ? 'warn' : '');
        html += mc('Window', fmtTokens(cw) + 't');
        html += mc('History', fmtTokens(ht) + 't');
        html += mc('Util', utilPct + '%', utilClass);
        if (stored) {
          html += mc('Segments', stored.segment_count);
        } else if ((live.tag_summary_count || 0) > 0) {
          html += mc('Summaries', live.tag_summary_count + ' (' + fmtTokens(live.tag_summary_tokens || 0) + 't)');
        } else {
          html += me();
        }

        // Util bar (full width)
        html += '<div class="util-bar"><div class="util-fill ' + barClass + '" style="width:' + Math.min(utilPct, 100) + '%"></div></div>';

        // Row 3: payload sizes with token counts
        html += mc('Initial', fmtPayload(live.initial_payload_kb, live.initial_payload_tokens));
        html += mc('Last Raw', fmtPayload(live.last_payload_kb, live.last_payload_tokens));
        html += mc('Enriched', fmtPayload(live.last_enriched_payload_kb, live.last_enriched_payload_tokens));
        if (stored && (live.tag_summary_count || 0) > 0) {
          html += mc('Summaries', live.tag_summary_count + ' (' + fmtTokens(live.tag_summary_tokens || 0) + 't)');
        } else {
          html += me();
        }

      } else if (stored) {
        // Stored-only session
        html += mc('Segments', stored.segment_count);
        var ratio = stored.compression_ratio > 0 ? Math.round(stored.compression_ratio * 100) + '%' : '--';
        var freed = stored.total_full_tokens - stored.total_summary_tokens;
        html += mc('Compression', ratio);
        html += mc('Freed', fmtNum(freed) + 't');
        html += me();
      }

      html += '</div>';

      // Active tags for live sessions
      if (live && live.active_tags && live.active_tags.length) {
        html += '<div class="session-tags">';
        live.active_tags.slice(0, 8).forEach(function(t) {
          html += '<span class="tag">' + t + '</span>';
        });
        if (live.active_tags.length > 8) html += '<span class="tag">+' + (live.active_tags.length - 8) + '</span>';
        html += '</div>';
      } else if (stored && stored.distinct_tags) {
        var tagHtml = (stored.distinct_tags || []).slice(0, 8).map(
          function(t) { return '<span class="tag">' + t + '</span>'; }
        ).join('');
        var more = (stored.distinct_tags || []).length > 8
          ? '<span class="tag">+' + ((stored.distinct_tags || []).length - 8) + '</span>' : '';
        html += '<div class="session-tags">' + tagHtml + more + '</div>';
      }

      if (stored) {
        var oldest = stored.oldest_segment ? new Date(stored.oldest_segment).toLocaleString() : '--';
        var newest = stored.newest_segment ? new Date(stored.newest_segment).toLocaleString() : '--';
        html += '<div class="session-time">' + oldest + ' \u2192 ' + newest + '</div>';
      }

      html += '</div>';
      return html;
    }).join('');
  }

  // Replay controls
  let replayRunning = false;

  window.startReplay = function() {
    const file = $('replay-file').value.trim();
    if (!file) { alert('Enter a prompts file path'); return; }

    $('replay-start').disabled = true;
    fetch('/dashboard/replay/start', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({file: file}),
    })
    .then(r => r.json().then(d => ({status: r.status, data: d})))
    .then(({status, data}) => {
      if (status >= 400) {
        alert(data.error || 'Failed to start replay');
        $('replay-start').disabled = false;
        return;
      }
      replayRunning = true;
      $('replay-stop').disabled = false;
      $('replay-progress').style.display = 'block';
      $('replay-fill').style.width = '0%';
      $('replay-fill').className = 'replay-bar-fill';
      $('replay-status').textContent = 'Starting... 0/' + data.total_prompts;
    })
    .catch(() => { $('replay-start').disabled = false; });
  };

  window.stopReplay = function() {
    fetch('/dashboard/replay/stop', {method: 'POST'});
    $('replay-status').textContent = 'Stopping...';
  };

  function handleHistoryIngestion(data) {
    const turns = data.turns_ingested || 0;
    const ms = data.elapsed_ms || 0;
    const el = $('ingestion-status');
    if (el) el.textContent = 'Ingested ' + turns + ' historical turns (' + Math.round(ms) + 'ms)';
    // Bootstrap baseline from ingested history token count
    if (data.baseline_history_tokens) {
      baselineHistoryTokens = data.baseline_history_tokens;
    }
  }

  var _ingestionFetchPending = false;
  function updateIngestionProgress(evt) {
    if (!evt.done || !evt.total) return;
    var done = evt.done, total = evt.total;
    var pct = Math.round((done / total) * 100);
    // Update progress bar fill if it exists in the DOM
    var fills = document.querySelectorAll('.ingestion-progress-fill');
    if (fills.length === 0 && !_ingestionFetchPending) {
      // Progress bar not rendered yet — fetch live sessions to create it
      _ingestionFetchPending = true;
      fetchLiveSessions();
      setTimeout(function() { _ingestionFetchPending = false; }, 1000);
      return;
    }
    fills.forEach(function(el) { el.style.width = pct + '%'; });
    // Update text label below progress bar
    var labels = document.querySelectorAll('.ingestion-progress-label');
    labels.forEach(function(el) { el.textContent = 'Ingesting: ' + done + '/' + total + ' (' + pct + '%)'; });
    // Update header ingestion status too
    var hdr = $('ingestion-status');
    if (hdr) hdr.textContent = 'Ingesting: ' + done + '/' + total + ' (' + pct + '%)';
  }

  function handleReplayProgress(data) {
    const pct = data.total > 0 ? Math.round((data.turn / data.total) * 100) : 0;
    $('replay-fill').style.width = pct + '%';
    const preview = data.prompt_preview ? ' \u2014 "' + data.prompt_preview.substring(0, 50) + '"' : '';
    $('replay-status').textContent = 'Turn ' + data.turn + '/' + data.total + ' (' + pct + '%)' + preview;
  }

  function handleReplayDone(data) {
    replayRunning = false;
    $('replay-start').disabled = false;
    $('replay-stop').disabled = true;
    const fill = $('replay-fill');
    if (data.status === 'complete') {
      fill.style.width = '100%';
      fill.className = 'replay-bar-fill done';
      $('replay-status').textContent = 'Complete \u2014 ' + data.turns_completed + '/' + data.total + ' turns';
    } else if (data.status === 'stopped') {
      fill.className = 'replay-bar-fill';
      $('replay-status').textContent = 'Stopped at turn ' + data.turns_completed + '/' + data.total;
    } else {
      fill.className = 'replay-bar-fill error';
      $('replay-status').textContent = 'Error: ' + (data.error || 'unknown');
    }
    // Final refresh after replay ends
    fetchSessions();
    updateSavings();
  }

  // Session filter
  window.filterBySession = function(sessionId) {
    if (!sessionId) return;
    activeSessionFilter = sessionId;
    $('session-filter').style.display = '';
    $('session-filter-id').textContent = sessionId;
    var rows = $('log-body').children;
    for (var i = 0; i < rows.length; i++) {
      rows[i].style.display = (rows[i].dataset.session === sessionId) ? '' : 'none';
    }
  };

  window.clearSessionFilter = function() {
    activeSessionFilter = null;
    $('session-filter').style.display = 'none';
    var rows = $('log-body').children;
    for (var i = 0; i < rows.length; i++) rows[i].style.display = '';
  };

  // GridManager: resizable, draggable, toggleable columns
  function GridManager(tableId, storageKey) {
    this.table = document.getElementById(tableId);
    if (!this.table) return;
    this.storageKey = storageKey;
    this.thead = this.table.querySelector('thead tr');
    this.colCount = this.thead.children.length;
    this.order = [];
    this.widths = {};
    this.hidden = [];
    for (var i = 0; i < this.colCount; i++) this.order.push(i);
    this._loadState();
    this._initColgroup();
    this._initResize();
    this._initDrag();
    this._applyHidden();
  }

  GridManager.prototype._loadState = function() {
    try {
      var raw = localStorage.getItem(this.storageKey);
      if (!raw) return;
      var s = JSON.parse(raw);
      if (s.order && s.order.length === this.colCount) this.order = s.order;
      if (s.widths) this.widths = s.widths;
      if (s.hidden) this.hidden = s.hidden;
      // Apply saved column order
      if (s.order && s.order.length === this.colCount) this._reorderAll();
    } catch(e) {}
  };

  GridManager.prototype._saveState = function() {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify({
        order: this.order, widths: this.widths, hidden: this.hidden
      }));
    } catch(e) {}
  };

  GridManager.prototype._initColgroup = function() {
    var cg = document.createElement('colgroup');
    for (var i = 0; i < this.colCount; i++) {
      var col = document.createElement('col');
      if (this.widths[i]) col.style.width = this.widths[i] + 'px';
      cg.appendChild(col);
    }
    this.table.insertBefore(cg, this.table.firstChild);
    this.colgroup = cg;
  };

  GridManager.prototype._initResize = function() {
    var self = this;
    var ths = this.thead.children;
    for (var i = 0; i < ths.length - 1; i++) { // skip last col (actions)
      var handle = document.createElement('div');
      handle.className = 'col-resize';
      handle.dataset.col = String(i);
      ths[i].appendChild(handle);
      handle.addEventListener('mousedown', function(e) {
        e.preventDefault();
        e.stopPropagation();
        var colIdx = parseInt(this.dataset.col);
        var startX = e.clientX;
        var col = self.colgroup.children[colIdx];
        var startW = col.offsetWidth || ths[colIdx].offsetWidth;
        this.classList.add('active');
        var hnd = this;
        function onMove(ev) {
          var w = Math.max(40, startW + (ev.clientX - startX));
          col.style.width = w + 'px';
        }
        function onUp() {
          hnd.classList.remove('active');
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
          var finalW = parseInt(col.style.width) || 40;
          self.widths[colIdx] = finalW;
          self._saveState();
        }
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      });
    }
  };

  GridManager.prototype._initDrag = function() {
    var self = this;
    var ths = this.thead.children;
    for (var i = 0; i < ths.length; i++) {
      ths[i].setAttribute('draggable', 'true');
      ths[i].dataset.logicalCol = String(i);
      ths[i].addEventListener('dragstart', function(e) {
        if (e.target.classList.contains('col-resize')) { e.preventDefault(); return; }
        e.dataTransfer.setData('text/plain', this.dataset.logicalCol);
        this.classList.add('dragging');
      });
      ths[i].addEventListener('dragend', function() {
        this.classList.remove('dragging');
        var allTh = self.thead.children;
        for (var j = 0; j < allTh.length; j++) allTh[j].classList.remove('drag-over');
      });
      ths[i].addEventListener('dragover', function(e) { e.preventDefault(); this.classList.add('drag-over'); });
      ths[i].addEventListener('dragleave', function() { this.classList.remove('drag-over'); });
      ths[i].addEventListener('drop', function(e) {
        e.preventDefault();
        this.classList.remove('drag-over');
        var fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
        var toIdx = parseInt(this.dataset.logicalCol);
        if (fromIdx === toIdx || isNaN(fromIdx) || isNaN(toIdx)) return;
        // Reorder in self.order
        var orderFrom = self.order.indexOf(fromIdx);
        var orderTo = self.order.indexOf(toIdx);
        if (orderFrom < 0 || orderTo < 0) return;
        self.order.splice(orderFrom, 1);
        if (orderFrom < orderTo) orderTo--;
        self.order.splice(orderTo, 0, fromIdx);
        self._reorderAll();
        self._saveState();
      });
    }
  };

  GridManager.prototype._reorderAll = function() {
    var rows = this.table.querySelectorAll('tr');
    for (var r = 0; r < rows.length; r++) {
      this._reorderRow(rows[r]);
    }
    // Reorder colgroup
    if (this.colgroup) {
      var cols = Array.from(this.colgroup.children);
      var frag = document.createDocumentFragment();
      for (var i = 0; i < this.order.length; i++) {
        if (cols[this.order[i]]) frag.appendChild(cols[this.order[i]]);
      }
      this.colgroup.innerHTML = '';
      this.colgroup.appendChild(frag);
    }
  };

  GridManager.prototype._reorderRow = function(tr) {
    var cells = Array.from(tr.children);
    if (cells.length !== this.colCount) return;
    var frag = document.createDocumentFragment();
    for (var i = 0; i < this.order.length; i++) {
      if (cells[this.order[i]]) frag.appendChild(cells[this.order[i]]);
    }
    tr.innerHTML = '';
    tr.appendChild(frag);
  };

  GridManager.prototype.reorderNewRow = function(tr) {
    // Check if order is default
    var isDefault = true;
    for (var i = 0; i < this.order.length; i++) {
      if (this.order[i] !== i) { isDefault = false; break; }
    }
    if (!isDefault) this._reorderRow(tr);
    // Apply hidden
    this._applyHiddenToRow(tr);
  };

  GridManager.prototype._applyHidden = function() {
    var rows = this.table.querySelectorAll('tr');
    for (var r = 0; r < rows.length; r++) this._applyHiddenToRow(rows[r]);
  };

  GridManager.prototype._applyHiddenToRow = function(tr) {
    var cells = tr.children;
    for (var c = 0; c < cells.length; c++) {
      var logIdx = this.order[c];
      if (logIdx !== undefined && this.hidden.indexOf(logIdx) >= 0) {
        cells[c].style.display = 'none';
      } else {
        cells[c].style.display = '';
      }
    }
  };

  GridManager.prototype.toggleColumn = function(logicalIdx) {
    var pos = this.hidden.indexOf(logicalIdx);
    if (pos >= 0) {
      this.hidden.splice(pos, 1);
    } else {
      this.hidden.push(logicalIdx);
    }
    this._applyHidden();
    this._saveState();
  };

  GridManager.prototype.isHidden = function(logicalIdx) {
    return this.hidden.indexOf(logicalIdx) >= 0;
  };

  GridManager.prototype.resetDefaults = function() {
    this.order = [];
    for (var i = 0; i < this.colCount; i++) this.order.push(i);
    this.widths = {};
    this.hidden = [];
    // Reset colgroup widths
    if (this.colgroup) {
      var cols = this.colgroup.children;
      for (var c = 0; c < cols.length; c++) cols[c].style.width = '';
    }
    this._reorderAll();
    this._applyHidden();
    try { localStorage.removeItem(this.storageKey); } catch(e) {}
  };

  // Column toggle menu
  window.toggleColMenu = function(btn) {
    var existing = document.querySelector('.col-menu');
    if (existing) { existing.remove(); return; }
    if (!gridManager) return;
    var menu = document.createElement('div');
    menu.className = 'col-menu';
    var headers = gridManager.thead.children;
    var names = [];
    for (var i = 0; i < headers.length; i++) {
      names.push(headers[i].textContent.replace(/[\n]/g, '').trim() || 'Col ' + i);
    }
    // Use logical indices (original order)
    for (var li = 0; li < gridManager.colCount; li++) {
      var label = document.createElement('label');
      var cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = !gridManager.isHidden(li);
      if (li === 0) { cb.disabled = true; cb.checked = true; } // T# always visible
      cb.dataset.logicalCol = String(li);
      cb.addEventListener('change', function() {
        gridManager.toggleColumn(parseInt(this.dataset.logicalCol));
      });
      label.appendChild(cb);
      label.appendChild(document.createTextNode(names[li] || 'Col ' + li));
      menu.appendChild(label);
    }
    btn.parentElement.style.position = 'relative';
    btn.parentElement.appendChild(menu);
    // Close on outside click
    setTimeout(function() {
      document.addEventListener('click', function closer(e) {
        if (!menu.contains(e.target) && e.target !== btn) {
          menu.remove();
          document.removeEventListener('click', closer);
        }
      });
    }, 0);
  };

  // SSE connection
  function connect() {
    $('conn-status').textContent = 'connecting...';
    const es = new EventSource('/dashboard/events');

    es.onopen = () => {
      $('conn-status').textContent = 'connected';
      document.querySelector('.dot').style.background = 'var(--green)';
    };
    es.onerror = () => {
      $('conn-status').textContent = 'reconnecting...';
      document.querySelector('.dot').style.background = 'var(--red)';
    };
    es.onmessage = (e) => {
      let data;
      try { data = JSON.parse(e.data); } catch { return; }

      if (data.type === 'snapshot') {
        handleSnapshot(data);
      } else if (data.type === 'request') {
        totalRequests++;
        waitSum += data.wait_ms || 0;
        inboundSum += data.inbound_ms || 0;
        contextSum += data.context_tokens || 0;
        totalContextInjected += data.context_tokens || 0;
        cumActualInput += data.input_tokens || 0;
        if (data.raw_input_tokens) cumBaselineInput += data.raw_input_tokens;
        latestSystemTokens = data.system_tokens || latestSystemTokens;
        historyLen = data.history_len || historyLen;
        compactedThrough = data.compacted_through || compactedThrough;
        addRequestRow(data);
        updateStats();
        updatePipeline();
        updateMemory();
        updateSavings();
      } else if (data.type === 'response') {
        handleResponse(data);
      } else if (data.type === 'turn_complete') {
        handleTurnComplete(data);
      } else if (data.type === 'compaction') {
        totalCompactions++;
        totalFreed += data.tokens_freed || 0;
        totalOriginalTokens += data.original_tokens || 0;
        totalSummaryTokens += data.summary_tokens || 0;
        addCompaction(data);
        updateStats();
        updateSavings();
        fetchSessions();
      } else if (data.type === 'tool_intercept') {
        totalIntercepts++;
        addToolIntercept(data);
        updateStats();
      } else if (data.type === 'ingested_turn') {
        addIngestedRow(data);
        updateIngestionProgress(data);
      } else if (data.type === 'history_ingestion') {
        handleHistoryIngestion(data);
      } else if (data.type === 'session_state_change') {
        fetchLiveSessions();
      } else if (data.type === 'replay_progress') {
        handleReplayProgress(data);
      } else if (data.type === 'replay_done') {
        handleReplayDone(data);
      }
    };
  }

  window.deleteSession = function(sid) {
    if (!confirm('Delete all stored segments for session ' + sid + '?')) return;
    fetch('/dashboard/sessions/' + sid, {method: 'DELETE'})
      .then(r => r.json())
      .then(data => { fetchSessions(); })
      .catch(() => {});
  };

  window.togglePassthrough = function(sid, enabled) {
    fetch('/dashboard/sessions/' + sid + '/passthrough', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({enabled: enabled}),
    })
    .then(r => r.json())
    .then(() => { fetchLiveSessions(); })
    .catch(() => {});
  };

  window.shutdownProxy = function() {
    if (!confirm('Shut down the proxy server?')) return;
    fetch('/dashboard/shutdown', {method: 'POST'});
    $('conn-status').textContent = 'shutting down...';
  };

  window.exportSession = function() {
    fetch('/dashboard/export')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        var ts = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        var name = 'vc-export-' + ts + '.json';
        var blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
        var a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = name;
        a.click();
        URL.revokeObjectURL(a.href);
      })
      .catch(function(err) { alert('Export failed: ' + err.message); });
  };

  // Manual compaction
  window.compactNow = function() {
    var btn = $('compact-btn');
    btn.disabled = true;
    btn.textContent = 'Compacting...';
    fetch('/dashboard/compact', {method: 'POST'})
      .then(function(r) { return r.json().then(function(d) { return {status: r.status, data: d}; }); })
      .then(function(res) {
        if (res.status === 409) {
          btn.textContent = 'Already compacting...';
        } else if (res.status >= 400) {
          btn.textContent = res.data.error || 'Error';
        } else if (res.data.status === 'no_action') {
          btn.textContent = 'Nothing to compact';
        } else {
          btn.textContent = 'Compacted ' + res.data.segments + ' segments';
        }
        setTimeout(function() {
          btn.textContent = 'Compact Now';
          btn.disabled = false;
        }, 3000);
      })
      .catch(function() {
        btn.textContent = 'Error';
        setTimeout(function() {
          btn.textContent = 'Compact Now';
          btn.disabled = false;
        }, 3000);
      });
  };

  // Request inspector
  var _inspectedData = null;

  window.inspectRequest = function(turn) {
    $('inspect-overlay').style.display = 'flex';
    $('inspect-subtitle').textContent = 'Turn ' + turn;
    $('inspect-body').innerHTML = '<span class="empty-state">loading...</span>';
    _inspectedData = null;

    fetch('/dashboard/requests/' + turn)
      .then(function(r) {
        if (!r.ok) throw new Error('Not found');
        return r.json();
      })
      .then(function(data) {
        _inspectedData = data;
        renderInspect(data);
      })
      .catch(function() {
        $('inspect-body').innerHTML = '<span class="empty-state">Request not in capture buffer</span>';
      });
  };

  function renderInspect(data) {
    var html = '';
    // Tags section
    var hasInbound = data.inbound_tags && data.inbound_tags.length;
    var hasResponse = data.response_tags && data.response_tags.length;
    if (hasInbound || hasResponse) {
      html += '<div style="display:flex;gap:24px;margin-bottom:12px">';
      html += '<div style="flex:1"><strong style="color:var(--accent)">Inbound Tags</strong>';
      html += '<div class="tag-cloud" style="margin-top:4px">';
      if (hasInbound) {
        data.inbound_tags.forEach(function(t) { html += '<span class="tag">' + escHtml(t) + '</span>'; });
      } else {
        html += '<span class="empty-state">none</span>';
      }
      html += '</div></div>';
      html += '<div style="flex:1"><strong style="color:var(--accent)">Response Tags</strong>';
      html += '<div class="tag-cloud" style="margin-top:4px">';
      if (hasResponse) {
        data.response_tags.forEach(function(t) { html += '<span class="tag">' + escHtml(t) + '</span>'; });
      } else {
        html += '<span class="empty-state">pending</span>';
      }
      html += '</div></div>';
      html += '</div>';
    }
    // System prompt
    if (data.system) {
      html += '<div style="margin-bottom:12px"><strong style="color:var(--accent)">System Prompt</strong>';
      html += ' <span style="color:var(--text-dim);font-size:11px">(' + estimateTokens(data.system) + ' tokens est.)</span>';
      html += '<pre style="background:var(--bg);padding:8px;border-radius:4px;white-space:pre-wrap;max-height:200px;overflow:auto;margin-top:4px;border:1px solid var(--border)">';
      var sysText = typeof data.system === 'string' ? data.system : JSON.stringify(data.system, null, 2);
      html += escHtml(sysText.substring(0, 5000));
      if (sysText.length > 5000) html += '\n... (' + sysText.length + ' chars total)';
      html += '</pre></div>';
    }
    // Messages
    html += '<div><strong style="color:var(--accent)">Messages</strong>';
    var allMsgs = data.messages || [];
    html += ' <span style="color:var(--text-dim);font-size:11px">(' + allMsgs.length + ' messages, newest first)</span></div>';
    for (var _ri = allMsgs.length - 1; _ri >= 0; _ri--) { var msg = allMsgs[_ri]; var i = _ri;
      var role = msg.role || '?';
      var roleColor = role === 'user' ? '#4a9' : role === 'assistant' ? '#49a' : role === 'system' ? '#a94' : '#999';
      html += '<div style="margin:8px 0;border-left:3px solid ' + roleColor + ';padding-left:8px">';
      html += '<div style="font-weight:bold;color:' + roleColor + '">[' + i + '] ' + role + '</div>';
      if (typeof msg.content === 'string') {
        html += '<pre style="background:var(--bg);padding:6px;border-radius:4px;white-space:pre-wrap;max-height:150px;overflow:auto;margin:4px 0;font-size:11px">' + escHtml(msg.content.substring(0, 3000));
        if (msg.content.length > 3000) html += '\n... (' + msg.content.length + ' chars)';
        html += '</pre>';
      } else if (Array.isArray(msg.content)) {
        msg.content.forEach(function(block) {
          var btype = block.type || 'unknown';
          var badge = '<span style="background:var(--border);padding:1px 6px;border-radius:3px;font-size:10px;margin-right:4px">' + btype + '</span>';
          html += '<div style="margin:4px 0">' + badge;
          if (btype === 'text') {
            var t = block.text || '';
            html += '<pre style="background:var(--bg);padding:6px;border-radius:4px;white-space:pre-wrap;max-height:150px;overflow:auto;display:inline-block;width:calc(100% - 16px);font-size:11px">' + escHtml(t.substring(0, 3000));
            if (t.length > 3000) html += '\n... (' + t.length + ' chars)';
            html += '</pre>';
          } else if (btype === 'tool_use') {
            html += '<span style="color:var(--text-dim);font-size:11px"> ' + (block.name || '') + '()</span>';
          } else if (btype === 'tool_result') {
            var rc = typeof block.content === 'string' ? block.content : JSON.stringify(block.content);
            html += '<pre style="background:var(--bg);padding:4px;border-radius:4px;white-space:pre-wrap;max-height:80px;overflow:auto;font-size:10px;color:var(--text-dim)">' + escHtml((rc || '').substring(0, 1000)) + '</pre>';
          } else if (btype === 'thinking') {
            html += '<span style="color:var(--text-dim);font-size:11px"> (' + ((block.thinking || '').length) + ' chars)</span>';
          } else {
            html += '<span style="color:var(--text-dim);font-size:11px"> ' + JSON.stringify(block).substring(0, 200) + '</span>';
          }
          html += '</div>';
        });
      }
      html += '</div>';
    }
    $('inspect-body').innerHTML = html;
  }

  function estimateTokens(s) {
    if (typeof s === 'string') return Math.round(s.length / 4);
    return Math.round(JSON.stringify(s).length / 4);
  }

  function escHtml(s) {
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  window.saveInspectedRequest = function() {
    if (!_inspectedData) return;
    var blob = new Blob([JSON.stringify(_inspectedData, null, 2)], {type: 'application/json'});
    var a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'request-turn-' + (_inspectedData.turn || 0) + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
  };

  window.closeInspect = function() {
    $('inspect-overlay').style.display = 'none';
    _inspectedData = null;
  };

  // Settings modal
  window.openSettings = function() {
    $('settings-overlay').style.display = 'flex';
    $('settings-body').innerHTML = '<span class="empty-state">loading...</span>';
    $('settings-status').textContent = '';
    $('settings-status').className = 'settings-status';
    fetch('/dashboard/settings')
      .then(function(r) {
        if (!r.ok) throw new Error('Failed to load settings');
        return r.json();
      })
      .then(function(data) { renderSettings(data); })
      .catch(function(err) {
        $('settings-body').innerHTML = '<span class="empty-state">' + err.message + '</span>';
      });
  };

  window.closeSettings = function() {
    $('settings-overlay').style.display = 'none';
  };

  var sectionHelp = {
    system:
      '<p>Read-only information about the engine configuration. These values are set at startup from your YAML config and cannot be changed at runtime.</p>' +
      '<dl>' +
      '<dt>Context Window</dt><dd>The maximum number of tokens your target LLM can process in a single request. All compaction thresholds, assembly budgets, and retrieval fractions are calculated relative to this value. A 120k window means the engine has 120,000 tokens to split between raw conversation history, retrieved summaries, and system context.</dd>' +
      '<dt>Tagger</dt><dd>The method used to generate semantic tags for each conversation turn. <strong>keyword</strong> uses deterministic regex pattern matching (fast, no API calls). <strong>llm</strong> sends conversation text to a language model for semantic understanding (slower, more accurate, understands nuance). Tags are the foundation of retrieval — they determine which stored summaries are relevant to the current query.</dd>' +
      '<dt>Summarizer</dt><dd>The LLM model used to create compaction summaries. When conversation history is compacted, this model reads the raw turns and produces a concise summary preserving key decisions, entities, and action items. Runs in a background thread so it does not block the next turn.</dd>' +
      '<dt>Storage</dt><dd>Where compacted segments and tag summaries are persisted. <strong>sqlite</strong> uses a local database with FTS5 full-text search. <strong>filesystem</strong> stores markdown files with YAML frontmatter and a JSON index. Both support the same operations; sqlite is recommended for performance.</dd>' +
      '</dl>',
    compaction:
      '<p>Compaction frees context window space by summarizing older conversation turns. When token usage crosses the soft threshold, the engine begins summarizing; at the hard threshold, it compacts immediately. Turns are grouped by tag, summarized by the LLM, and stored externally. The summaries can then be retrieved on-demand when their topics come up again.</p>' +
      '<dl>' +
      '<dt>Soft Threshold</dt><dd>Fraction of the context window that triggers voluntary compaction. When estimated token usage exceeds this ratio (e.g., 0.70 = 70% of window), the engine begins summarizing the oldest unprotected turns. Lower values compact more aggressively — more summaries and less raw history, but earlier recall via retrieval.</dd>' +
      '<dt>Hard Threshold</dt><dd>Fraction of the context window that forces immediate compaction. If token usage reaches this level (e.g., 0.85 = 85%), compaction runs before the next turn regardless. Must be strictly greater than soft threshold. The gap between soft and hard gives a buffer zone for graceful compaction.</dd>' +
      '<dt>Protected Turns</dt><dd>Number of most-recent conversation turns that are never compacted. These stay as raw messages in the history. Higher values preserve more recent context but leave less room for retrieved summaries. With a small context window, keep this low (3–4); with a large window, 6–8 is typical.</dd>' +
      '<dt>Min Summary Tokens</dt><dd>Minimum length for a compaction summary. Prevents the summarizer from generating a summary too terse to be useful. Even if the original segment is very short, the summary will be at least this many tokens. Too low and summaries lose critical detail.</dd>' +
      '<dt>Max Summary Tokens</dt><dd>Maximum length for a compaction summary. Caps summary size to prevent a single compacted segment from consuming too much of the retrieval budget. Must be greater than or equal to min. Typical range: 500–2000 depending on context window size.</dd>' +
      '</dl>',
    tagging:
      '<p>Tags are semantic labels assigned to each conversation turn (e.g., "authentication", "database", "deployment"). They drive retrieval: when you ask about a topic, the engine matches query tags against tags on stored segments to find relevant summaries. The LLM tagger generates tags from conversation content; the heuristic overrides are regex safety nets that catch specific query patterns the LLM might miss.</p>' +
      '<dl>' +
      '<dt>Broad Heuristic</dt><dd>A set of regex patterns that detect broad, retrospective queries like "what did we discuss?", "summarize everything", or "recap our conversation". When a broad query is detected, retrieval switches to a special branch that fetches <strong>all</strong> stored tag summaries (not just tag-overlap matches), giving the LLM a complete picture. This heuristic fires as a post-LLM override — if the LLM already flagged the query as broad, the heuristic is skipped. Disable if your tagger model reliably detects broad queries on its own.</dd>' +
      '<dt>Temporal Heuristic</dt><dd>A set of regex patterns that detect time-referencing queries like "what was the first thing we discussed?", "early on", or "going way back". When temporal intent is detected, retrieval fetches segment-level summaries sorted chronologically (oldest first), providing detailed recall of early conversation content that may have been compacted long ago. Disable if your tagger model reliably detects temporal intent.</dd>' +
      '</dl>',
    retrieval:
      '<p>Retrieval fetches stored summaries relevant to the current user message. The engine tags the incoming query, then matches those tags against tags on stored segments. Matching summaries are ranked, trimmed to budget, and assembled into a context block prepended to the LLM request as a <code>&lt;virtual-context&gt;</code> block.</p>' +
      '<dl>' +
      '<dt>Active Tag Lookback</dt><dd>How many recent turns to scan when building the "active tag" set (topics currently under discussion). Tags that appear in recent turns are considered active and <strong>skipped</strong> during retrieval, since that content is already present in the raw conversation history. Higher values skip more tags; lower values retrieve more aggressively.</dd>' +
      '<dt>Anchorless Lookback</dt><dd>When the tagger produces a fallback result (no strong tag match for the query), this controls how many recent turns define the "working set" for fallback retrieval. The engine collects tags from these recent turns and fetches their summaries. Larger values cast a wider net but may pull in less-relevant content.</dd>' +
      '<dt>Max Results</dt><dd>Maximum number of stored summaries returned per retrieval query. Each result is a compacted segment summary. Higher values provide more context for the LLM but consume more of the token budget. With a small context window, keep this low (3–5); large windows can support 10–20.</dd>' +
      '<dt>Budget Fraction</dt><dd>The fraction of the total context window allocated to retrieved summaries. For example, 0.25 on a 120k window = 30k tokens max for retrieved content. This limit prevents retrieval from crowding out the raw conversation history. The remaining budget goes to conversation messages and system context.</dd>' +
      '<dt>Include Related</dt><dd>When enabled, retrieval expands its search to include tags semantically related to the matched tags (via the <code>related_tags</code> field produced by the tagger). This bridges vocabulary mismatches — for example, finding content tagged "database" when the user says "storage", or "auth" when they say "login". Recommended to keep enabled.</dd>' +
      '</dl>',
    assembly:
      '<p>Assembly takes retrieved summaries and builds the final context block injected into every LLM request. It enforces token budgets, orders tags by priority (from tag_rules), and optionally adds a context hint — a brief topic list that tells the LLM what has been discussed previously so it does not claim ignorance about compacted topics.</p>' +
      '<dl>' +
      '<dt>Tag Context Max</dt><dd>Total token budget for injected tag summaries. Retrieved summaries are included highest-priority first and trimmed when this limit is reached. This value is synced to the retriever budget, so changing it here also updates the retrieval cap. Higher values provide richer context but leave less room for conversation history.</dd>' +
      '<dt>Recent Turns Kept</dt><dd>Number of recent conversation turns always included in the filtered history sent to the LLM, regardless of whether they match the current tags. Ensures the LLM always sees the most recent exchanges for continuity. Set to 0 to rely entirely on tag-based filtering.</dd>' +
      '<dt>Context Hint</dt><dd>When enabled, injects a brief topic list into the context after the first compaction occurs. This tells the LLM "you have previously discussed: [topic1, topic2, ...]" so it knows stored knowledge exists and can reference it naturally rather than claiming ignorance about compacted topics. Strongly recommended.</dd>' +
      '<dt>Hint Max Tokens</dt><dd>Token budget for the context hint block. Controls how much space the topic list can consume. Typically 100–300 tokens is sufficient. Only relevant when Context Hint is enabled.</dd>' +
      '</dl>',
    summarization:
      '<p>Controls LLM behavior when generating compaction summaries. When older conversation turns are compacted, the summarizer model reads the raw messages and produces a concise summary. These summaries are stored and later retrieved when their topics become relevant again.</p>' +
      '<dl>' +
      '<dt>Temperature</dt><dd>Controls randomness in the summarizer output. <strong>0</strong> = fully deterministic (same input always produces the same summary). Higher values introduce variation and creativity. For compaction summaries, low values (0.1–0.4) are recommended to preserve factual accuracy and consistency. Values above 1.0 may produce unreliable summaries.</dd>' +
      '</dl>'
  };

  function sectionHeader(title, helpKey) {
    return '<div class="section-header"><h3>' + title + '</h3>' +
      '<button class="help-btn" data-help="' + helpKey + '" onclick="toggleHelp(this)">?</button></div>' +
      '<div class="help-content" data-help-for="' + helpKey + '" style="display:none">' +
      (sectionHelp[helpKey] || '') + '</div>';
  }

  window.toggleHelp = function(btn) {
    var key = btn.dataset.help;
    var content = document.querySelector('[data-help-for="' + key + '"]');
    if (!content) return;
    var visible = content.style.display !== 'none';
    // Close all others
    document.querySelectorAll('.help-content').forEach(function(el) { el.style.display = 'none'; });
    document.querySelectorAll('.help-btn').forEach(function(el) { el.classList.remove('active'); });
    if (!visible) {
      content.style.display = 'block';
      btn.classList.add('active');
    }
  };

  function renderSettings(data) {
    var html = '';
    // Readonly section
    html += '<div class="settings-section">' + sectionHeader('System', 'system');
    html += readonlyRow('Context Window', fmtNum(data.readonly.context_window) + ' tokens', 'Max tokens the target LLM accepts');
    html += readonlyRow('Tagger', data.readonly.tagger_type + (data.readonly.tagger_model ? ' / ' + data.readonly.tagger_model : ''), 'Tag generation method and model');
    html += readonlyRow('Summarizer', data.readonly.summarizer_model, 'Model used for compaction summaries');
    html += readonlyRow('Storage', data.readonly.storage_backend, 'Where segments and summaries are persisted');
    html += '</div>';
    // Compaction
    html += '<div class="settings-section">' + sectionHeader('Compaction', 'compaction');
    html += sliderRow('compaction', 'soft_threshold', 'Soft Threshold', 'Start compacting when context fills to this fraction', data.compaction.soft_threshold, 0.1, 0.95, 0.05);
    html += sliderRow('compaction', 'hard_threshold', 'Hard Threshold', 'Force immediate compaction at this fill level', data.compaction.hard_threshold, 0.2, 0.99, 0.01);
    html += numberRow('compaction', 'protected_recent_turns', 'Protected Turns', 'Recent turns shielded from compaction', data.compaction.protected_recent_turns, 1, 20);
    html += numberRow('compaction', 'min_summary_tokens', 'Min Summary Tokens', 'Floor for compaction summary length', data.compaction.min_summary_tokens, 50, 5000);
    html += numberRow('compaction', 'max_summary_tokens', 'Max Summary Tokens', 'Ceiling for compaction summary length', data.compaction.max_summary_tokens, 100, 10000);
    html += '</div>';
    // Tagging
    html += '<div class="settings-section">' + sectionHeader('Tagging', 'tagging');
    html += toggleRow('tagging', 'broad_heuristic_enabled', 'Broad Heuristic', 'Regex fallback to catch broad queries the LLM missed', data.tagging.broad_heuristic_enabled);
    html += toggleRow('tagging', 'temporal_heuristic_enabled', 'Temporal Heuristic', 'Regex fallback to catch temporal queries the LLM missed', data.tagging.temporal_heuristic_enabled);
    html += '</div>';
    // Retrieval
    html += '<div class="settings-section">' + sectionHeader('Retrieval', 'retrieval');
    html += numberRow('retrieval', 'active_tag_lookback', 'Active Tag Lookback', 'Recent turns scanned for active topic tags', data.retrieval.active_tag_lookback, 1, 20);
    html += numberRow('retrieval', 'anchorless_lookback', 'Anchorless Lookback', 'Working-set turns used for fallback retrieval', data.retrieval.anchorless_lookback, 1, 20);
    html += numberRow('retrieval', 'max_results', 'Max Results', 'Max stored summaries returned per query', data.retrieval.max_results, 1, 50);
    html += sliderRow('retrieval', 'max_budget_fraction', 'Budget Fraction', 'Context window share for retrieved summaries', data.retrieval.max_budget_fraction, 0.05, 0.5, 0.05);
    html += toggleRow('retrieval', 'include_related', 'Include Related', 'Expand retrieval to semantically related tags', data.retrieval.include_related);
    html += '</div>';
    // Assembly
    html += '<div class="settings-section">' + sectionHeader('Assembly', 'assembly');
    html += numberRow('assembly', 'tag_context_max_tokens', 'Tag Context Max', 'Token budget for injected tag summaries', data.assembly.tag_context_max_tokens, 1000, 100000);
    html += numberRow('assembly', 'recent_turns_always_included', 'Recent Turns Kept', 'Turns always included regardless of tag match', data.assembly.recent_turns_always_included, 0, 10);
    html += toggleRow('assembly', 'context_hint_enabled', 'Context Hint', 'Inject a topic list into context after compaction', data.assembly.context_hint_enabled);
    html += numberRow('assembly', 'context_hint_max_tokens', 'Hint Max Tokens', 'Token budget for the context hint block', data.assembly.context_hint_max_tokens, 50, 1000);
    html += '</div>';
    // Summarization
    html += '<div class="settings-section">' + sectionHeader('Summarization', 'summarization');
    html += sliderRow('summarization', 'temperature', 'Temperature', 'LLM randomness for compaction summaries (0 = deterministic)', data.summarization.temperature, 0, 2, 0.1);
    html += '</div>';

    $('settings-body').innerHTML = html;
    // Bind slider events
    document.querySelectorAll('.settings-slider').forEach(function(sl) {
      sl.addEventListener('input', function() {
        this.nextElementSibling.textContent = this.value;
      });
    });
    // Bind toggle events
    document.querySelectorAll('.settings-toggle').forEach(function(btn) {
      btn.addEventListener('click', function() {
        this.classList.toggle('on');
      });
    });
  }

  function labelHtml(label, desc) {
    var d = desc ? '<span class="settings-desc">' + desc + '</span>' : '';
    return '<div class="settings-label">' + label + d + '</div>';
  }
  function readonlyRow(label, value, desc) {
    return '<div class="settings-row">' + labelHtml(label, desc) +
      '<span class="settings-value">' + value + '</span></div>';
  }
  function numberRow(section, key, label, desc, value, min, max) {
    return '<div class="settings-row">' + labelHtml(label, desc) +
      '<input class="settings-input" type="number" data-section="' + section +
      '" data-key="' + key + '" value="' + value + '" min="' + min + '" max="' + max + '"></div>';
  }
  function sliderRow(section, key, label, desc, value, min, max, step) {
    return '<div class="settings-row">' + labelHtml(label, desc) +
      '<input class="settings-slider" type="range" data-section="' + section +
      '" data-key="' + key + '" value="' + value + '" min="' + min + '" max="' + max +
      '" step="' + step + '">' +
      '<span class="settings-slider-val">' + value + '</span></div>';
  }
  function toggleRow(section, key, label, desc, value) {
    return '<div class="settings-row">' + labelHtml(label, desc) +
      '<button class="settings-toggle' + (value ? ' on' : '') +
      '" data-section="' + section + '" data-key="' + key + '"></button></div>';
  }

  window.saveSettings = function() {
    var body = {};
    // Collect number inputs
    document.querySelectorAll('.settings-input').forEach(function(inp) {
      var section = inp.dataset.section, key = inp.dataset.key;
      if (!body[section]) body[section] = {};
      body[section][key] = Number(inp.value);
    });
    // Collect sliders
    document.querySelectorAll('.settings-slider').forEach(function(sl) {
      var section = sl.dataset.section, key = sl.dataset.key;
      if (!body[section]) body[section] = {};
      body[section][key] = Number(sl.value);
    });
    // Collect toggles
    document.querySelectorAll('.settings-toggle').forEach(function(btn) {
      var section = btn.dataset.section, key = btn.dataset.key;
      if (!body[section]) body[section] = {};
      body[section][key] = btn.classList.contains('on');
    });

    var statusEl = $('settings-status');
    statusEl.textContent = 'Saving...';
    statusEl.className = 'settings-status';
    fetch('/dashboard/settings', {
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(body),
    })
    .then(function(r) { return r.json().then(function(d) { return {status: r.status, data: d}; }); })
    .then(function(res) {
      if (res.status >= 400) {
        statusEl.textContent = res.data.error || 'Save failed';
        statusEl.className = 'settings-status error';
      } else {
        statusEl.textContent = 'Saved';
        statusEl.className = 'settings-status ok';
        renderSettings(res.data);
        setTimeout(function() { statusEl.textContent = ''; }, 2000);
      }
    })
    .catch(function(err) {
      statusEl.textContent = err.message;
      statusEl.className = 'settings-status error';
    });
  };

  // Initialize grid manager
  gridManager = new GridManager('log-table', 'vc-grid-request-log');

  // Tick uptime every second
  setInterval(updateStats, 1000);
  // Refresh sessions periodically (catches compaction results even if events missed)
  setInterval(fetchSessions, 15000);
  // Refresh live sessions periodically
  setInterval(fetchLiveSessions, 10000);
  connect();
})();
</script>
</body>
</html>
